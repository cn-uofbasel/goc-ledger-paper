\documentclass[9pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
    						                 % TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{hyperref}
\usepackage{doi}
\usepackage{pf2}
\usepackage{todonotes}

%\usepackage{amsthm}
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}{Lemma}

\newcommand{\defeq}{\overset{\mathrm{def}}{=}}
\newcommand{\mergeop}{\overset{\sqcup}\rightarrow}
\newcommand{\localop}{\overset{\textbf{local}}\rightarrow}
\newcommand{\anyop}[1]{\overset{#1}\rightarrow}

\title{State-based Conflict-Free Replicated Ledger}
\author{Erick Lavoie}
%\date{March, 13, 2023}							% Activate to display a given date or no 

\begin{document}
\maketitle


\begin{abstract}
The electronic asset transfer problem, which is solved by many replicated ledgers, has been shown to not require consensus. To our knowledge, all newer designs that leverage this property are based on a causality-based operation view that makes reasoning about and efficiently implementing replicated ledgers harder than necessary.

We reformulate the design of a replicated ledger as a state-based conflict-free replicated data type (CRDT) based on grow-only counters. This lowers requirements on message delivery to eventual delivery of the latest state transitively. Moreover, the system can be analyzed by reasoning only about the states and differences between states of the accounts, which significantly simplifies the presentation of key algorithms. This better highlights that the key property enabling eventually-consistent ledgers is that the positive contribution of a sender account to a receiver account's balance only needs to be accounted for \textit{eventually}, allowing senders to decrease their balance independently of receivers. Moreover, as a departure from previous designs, we also show that a conflict-free replicated ledger converges even in the presence of \textit{overspending}, albeit to a negative account balance. This is useful for designing eventually-consistent distributed systems in which a \textit{temporary negative balance} is not critical, because, \textit{e.g.}, users have to restore a non-negative balance to maintain access. Finally, in our state-based approach, \textit{overspending requires concurrent transfers from different replicas to different receivers}: strictly sequential operations on the same account cannot lead to overspending and concurrent transfers from the same account to the same receiver will result in the amount transferred to be smaller or equal than the available balance.

In this paper, we therefore present a state-based conflict-free replicated ledger and prove its convergence, the conditions under which overspending arises, as well as global safety and liveness conditions of the resulting account balances. We show that our design provides these properties in crash-stop, crash-recovery, and fail-silent system models, which is appropriate to any deployment in which all replicas are managed by trusted entities. We discuss different design dimensions to inform designers of possible choices depending on application requirements. We also outline remaining challenges to obtain similar properties in open systems in which replicas might arbitrarily deviate from our algorithms.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Contributions:
\begin{itemize}
	\item We present the design of a distributed ledger as a state-based conflict-free replicated data type and prove its convergence, as well as its balance safety and liveness properties;
	\item We highlight the design possibilities around token creation, enforcing strictly positive account balances, and management of replicas to guide system designers;
	\item We highlight future research directions that are opened by our approach, especially in implementing eventually consistent ledgers in adversarial open settings.
\end{itemize}

\section{State-based Eventually-Consistent Ledger}

In this section, we present the design of eventually-consistent ledgers in two parts: we present eventually-consistent \textit{accounts} (Section~\ref{sec:account}) and then the eventually-consistent \textit{ledgers} proper (Section~\ref{sec:ledger}). We present the state and operations on both accounts and ledgers at a high-level to outline a \textit{family} of designs that are eventually-consistent: this will pave the way for a discussion of design dimensions (Section~\ref{sec:design-issues}) that can turn this high-level design into concrete implementations. Our notation and conventions are explained as they are introduced and collected in Appendix~\ref{apdx:notation}.

\subsection{Account}
\label{sec:account}

Account replicas track the current balance of tokens for a given owner identified by their \textit{identifier}, shorten as $id$. The state of an account is decomposed into multiple internal counters such that all counters are \textit{monotonically increasing}, \textit{i.e.}, every operation leaves counters either unchanged or larger. 

Before explaining what each internal counter represents, we give an overview of account operations. Each owner can  \textit{create} new tokens, if they have the capability; \textit{burn} tokens they own; and transfer some or all their tokens to other accounts, identified by different $id$s. This is similar to existing crypto-token designs, such as (CITE). In contrast to the previous examples, we split the transfer into two operations: the sender \textit{gives} tokens to a receiver account, which immediately decreases the balance of the sender; however, the balance of the receiver is only increased after an explicit \textit{acknowledgement}. This decomposition enables the reception of tokens to be tracked as a separate event: this allows, for example, other replicas to check if the receiver account has received (and accepted) the tokens.\footnote{It is possible to always automatically acknowledge the reception of tokens immediately upon reception and not expose the acknowledgment operation to the user. However, having the operation performed explicitly also gives the opportunity to the receiver to ignore tokens sent to them. We therefore prefer the explicit operation.} The implementation of operations follows from both principles, with each operation modifying separate internal counter(s). 

We first present the state and operations in the following section (Section~\ref{sec:account:state-operations}), and the ordering and merging operations necessary for concurrency, in the next (Section~\ref{sec:account:ordering-merging}).

\subsubsection{State and Operations}
\label{sec:account:state-operations}

The implementation of the state and corresponding operations is listed in Algorithm~\ref{alg:account}. 

\begin{algorithm}
\begin{algorithmic}[1]
   \State \textbf{Require} $\mathds{C}$, the set of identifiers allowed to create tokens
   \State
   \Function{initialize$_\mathds{A}$}{\textit{id}}
    	\State $A_{\scriptsize\textbf{id}} \leftarrow id$
	\State $A_\uparrow ~\leftarrow 0$       \Comment{Created amount (real positive number)}
	\State $A_\downarrow ~\leftarrow 0$   \Comment{Burned amount (real positive number)}
	\State $A_\rightarrow \leftarrow \{ \}$ \Comment{GivenTo: Dictionary of $\textit{id}$s associated to $\textit{amount}$s}
	\State $A_\leftarrow \leftarrow \{ \}$ \Comment{AckFrom: Dictionary of $\textit{id}$s associated to  $\textit{amount}$s}
    	\State \Return $A$
    \EndFunction
    \State
    \Function{create}{$A,\textit{amount}$} 
    	\If{$A_{\scriptsize\textbf{id}} \in \mathds{C} \wedge \textit{amount} > 0$} 
	      	 \State $A' \leftarrow \textit{copy}(A)$
		 \State $A'_\uparrow \leftarrow A_\uparrow + \textit{amount}$
		 \State \Return $A'$
	\Else
		\State \Return $A$
	\EndIf

    \EndFunction
    \State
     \Function{burn}{$A,\textit{amount}$}  
    	\If{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$} \label{ln:burn-balance-check}
		 \State $A' \leftarrow \textit{copy}(A)$
		 \State $A'_\downarrow \leftarrow A_\downarrow + \textit{amount}$
		 \State \Return $A'$
	\Else
		\State \Return $A$
	\EndIf
    \EndFunction
    \State
    \Function{giveTo}{$A,\textit{amount}, \textit{id}$}  
    	\If{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}  \label{ln:give-balance-check}
	        \State $A' \leftarrow \textit{copy}(A)$
		\If{$id \notin A_{\rightarrow *}$}
			\State $A'_{\rightarrow}[id] \leftarrow \textit{amount}$ 
		\Else
		         \State $A'_{\rightarrow}[id] \leftarrow A_{\rightarrow}[id] + \textit{amount}$ 
		\EndIf
		\State \Return $A'$
	\Else
		\State \Return $A$
	\EndIf

    \EndFunction
    \State
    \Function{ackFrom}{$A, B$}
        \If{$\texttt{unackedFrom}(A,B) > 0 \wedge \texttt{balance}(B) \geq 0$}
                \State $A' \leftarrow \textit{copy}(A)$
		\If{$B_{\scriptsize\textbf{id}} \notin A_{\leftarrow *}$}
			 \State $A'_{\leftarrow}[B_{\scriptsize\textbf{id}}] \leftarrow B_{\rightarrow}[A_{\scriptsize\textbf{id}}]$
		\Else
			 \State $A'_{\leftarrow}[B_{\scriptsize\textbf{id}}] \leftarrow \texttt{max}(A_{\leftarrow}[B_{\scriptsize\textbf{id}}], B_{\rightarrow}[A_{\scriptsize\textbf{id}}])$ 
		\EndIf
		\State \Return $A'$
        \Else
        		\State \Return $A$
        \EndIf

    \EndFunction
    \end{algorithmic}
\caption{\label{alg:account} Account: State Initialization and State-Changing Operations}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
    \State
        \Function{balance}{A}
        \State $\textit{debits} \leftarrow A_\uparrow + \sum\limits_{id \in A_{\leftarrow *}} A_{\leftarrow}[id]$ 
        \Comment{Keys of $A_\leftarrow$ written $A_{\leftarrow *}$}
        \State $\textit{credits} \leftarrow A_\downarrow + \sum\limits_{id \in A_{\rightarrow *}} A_{\rightarrow}[id]$
        \Comment{Keys of $A_\rightarrow$ written $A_{\rightarrow *}$}
        \State \Return $\textit{debits} - \textit{credits}$
    \EndFunction
    \State
    \Function{unackedFrom}{$A, B$}
        \If{$A_{\scriptsize\textbf{id}} \in B_{\rightarrow *} \wedge B_{\scriptsize\textbf{id}} \in A_{\leftarrow *} $}
        		\State \Return $B_{\rightarrow A_{\tiny\textbf{id}}} - A_{\leftarrow B_{\tiny\textbf{id}}}$
	\ElsIf{$A_{\scriptsize\textbf{id}} \in B_{\rightarrow *}$}
		\State \Return $B_{\rightarrow A_{\tiny\textbf{id}}}$
	\Else
		\State \Return $0$
	\EndIf
    \EndFunction
    \end{algorithmic}
\caption{\label{alg:account} Account: Query Operations}
\end{algorithm}

A replica of an account belonging to owner $id$ is created with \texttt{initialize}. This initializes the internal identifier $A_{\textbf{id}}$ to $id$, the number of created tokens $A_\uparrow$ to $0$, the number of burned tokens $A_\downarrow$ to $0$, the dictionary of given tokens $A_\rightarrow$ to an empty dictionary, and the dictionary of acknowledged tokens $A_\leftarrow$ to an empty dictionary as well.\footnote{The left or right direction of the arrow notation suggests the corresponding direction of funds, respectively into or out from an account.}

The \texttt{create} operation takes the current state of an account $A$ and a requested \textit{amount} then returns a new state $A'$.\footnote{A practical implementation may actually encapsulate the state of an account in an object and modify it in place. We explicitly associate the different states to different variables to make the labels of the states in proofs (Section~\ref{sec:proofs}) easier to relate to the implementation.} Only allowed creators, \textit{i.e.}, those with ids within the set of allowed identifiers $\mathds{C}$, may create new tokens. The set of allowed creator identifiers might be distributed to replicas beforehand or enforced through cryptographic mechanisms. If the owner of the account has the necessary permission, the creation counter $A'_\uparrow$ is increased by \textit{amount}. This has the effect of increasing the balance of $A$ by \textit{amount}. Otherwise, the counter is unchanged ($A'_\uparrow=A_\uparrow$) and the balance remains the same.

The \texttt{burn} operation is similar to \texttt{create} with an opposite effect on the balance: it takes the current state of an account $A$ and a requested \textit{amount} to burn, then returns a new state $A'$. If the balance is equal or larger than \textit{amount}, the burn counter $A'_\downarrow$ is increased by \textit{amount}, and the balance correspondingly decreased by the same amount. Otherwise, $A'_\downarrow = A_\downarrow$. In contrast, to \texttt{create} any account is allowed to burn tokens. Restricting burning tokens to a set of identifiers would also be possible. However, the restriction would not be effective unless transfer operations were also restricted to only valid addresses,\footnote{Giving to an invalid or unused address effectively makes the tokens unavailable, similar to burning.} which in turn would require tracking the set of valid accounts. We therefore take the simpler and more open approach of allowing any account to burn tokens. 

The \texttt{giveTo} operation sends \textit{amount} tokens from account $A$ to the recipient account associated to $id$, resulting in a new state $A'$. The account state tracks the total amount ever sent to $id$ using the dictionary $A_{\rightarrow}$, using $id$ as a key to access the associated monotonic counter, written $A_{\rightarrow}[id]$. This counter is only increased if the local balance is higher or equal than the \textit{amount} sent.

The \texttt{ackFrom} operation acknowledges the reception of tokens from account $B$ by account $A$, resulting in new state $A'$. The implementation simply takes the maximum value of the tokens sent $B_{\rightarrow A_{\tiny \textbf{id}}}$ and the previously acknowledged tokens $A_{\leftarrow B_{\tiny \textbf{id}}}$. At all times the former is equal or larger than the latter.

The \texttt{balance} of an account $A$ performs additions and subtractions on counters corresponding to individual operations to compute the total balance of an account. It does not modify the state of the account. The implementation first computes the \textit{debits}, \textit{i.e.}, the sum of the amounts that increase the balance: that corresponds to the number of created tokens and the sum of the tokens acknowledged from all other accounts. Second, it computes the \textit{credits}, \textit{i.e.}, the sum of the amounts that decrease the balance: that corresponds to the number of tokens burnt and the sum of tokens given to all other accounts. The total is the difference between the \textit{debits} and the \textit{credits}.

The last operation, \texttt{unackedFrom} computes the sum of tokens sent from account $B$ that have not yet been acknowledged by account $A$. It does not modifies the state of $A$ nor $B$. This is implemented by subtracting the tokens acknowledged by $A$ from $B$, from the tokens sent by $B$ to $A$. If the result is greater than zero, there are unacknowledged tokens.

\subsubsection{Ordering and Merging}
\label{sec:account:ordering-merging}

The next two operations, shown in Algorithm~\ref{alg:account-ordering}, respectively establish a partial order between the different states of replicas, and enable merging different states, possibly modified concurrently, to obtain a new state.

\begin{algorithm}
\begin{algorithmic}[1]
    \Function{$\leq_\mathds{A}$}{$A$, $A'$} \Comment{Compare, call written in infix notation, \textit{e.g.}, $A \leq_\mathds{A}  A'$}
        \State $\textit{created} \leftarrow A_\uparrow \leq A'_\uparrow$
        \State $\textit{burned} \leftarrow A_\downarrow \leq A'_\downarrow$
        \State $\textit{given} \leftarrow A_{\rightarrow *} \subseteq A'_{\rightarrow *} \wedge \bigwedge\limits_{id \in A_{\rightarrow *}} A_{\rightarrow}[id] \leq A'_{\rightarrow}[id]$ \Comment{Keys of $A_\rightarrow$ written $A_{\rightarrow *}$}
        \State $\textit{acked} \leftarrow A_{\leftarrow *} \subseteq A'_{\leftarrow *} \wedge \bigwedge\limits_{id \in A_{\leftarrow *}} A_{\leftarrow}[id] \leq A'_{\leftarrow}[id]$
        \State \Return $A_{\footnotesize \textbf{id}} = A'_{\footnotesize \textbf{id}} \wedge \textit{created} \wedge \textit{burned} \wedge \textit{given} \wedge \textit{acked}$
    \EndFunction
    \State
    \Function{$\sqcup_\mathds{A}$}{$A$, $A'$} \Comment{Merge, call written in infix notation, \textit{e.g.}, $A \sqcup_\mathds{A}  A'$}
    	\If{$A_{\footnotesize \textbf{id}} \neq A'_{\footnotesize \textbf{id}}$}
		\textbf{error}
	\EndIf
	\State
        \State $A'' \leftarrow \texttt{initialize}(A_{\footnotesize \textbf{id}})$
        \State $A''_\uparrow \leftarrow \texttt{max}(A_\uparrow, A'_\uparrow)$
        \State $A''_\downarrow \leftarrow \texttt{max}(A_\downarrow, A'_\downarrow)$ 
        \State
        \State $R \leftarrow A_{\rightarrow *} \cup A_{\rightarrow *}'$ \Comment{Receiver ids}
	\For{$id ~\textbf{in}~ R$}
		\If{$id \in A_{\rightarrow *} \wedge id \in A'_{\rightarrow *} $}
			\State $A''_{\rightarrow}[id] \leftarrow \texttt{max}(A_{\rightarrow}[id], A'_{\rightarrow}[id])$
		\ElsIf{$id \in A_{\rightarrow *}$}
			\State $A''_{\rightarrow}[id] \leftarrow A_{\rightarrow}[id]$
		\Else
			\State $A''_{\rightarrow}[id] \leftarrow A'_{\rightarrow}[id]$
		\EndIf
	\EndFor
	\State
	\State $S \leftarrow A_{\leftarrow *} \cup A_{\leftarrow *}'$ \Comment{Sender ids}
	\For{$id ~\textbf{in}~S$}
		\If{$id \in A_{\leftarrow *} \wedge id \in A_{\leftarrow *}'$}
			\State $A''_{\leftarrow}[id] \leftarrow \texttt{max}(A_{\leftarrow}[id], A'_{\leftarrow}[id])$
		\ElsIf{$id \in A_{\leftarrow *}$}
			\State $A''_{\leftarrow}[id] \leftarrow A_{\leftarrow}[id]$
		\Else
			\State $A''_{\leftarrow}[id] \leftarrow A'_{\leftarrow}[id]$
		\EndIf
	\EndFor
	\State
	\State \Return $A''$	
    \EndFunction
\end{algorithmic}
\caption{\label{alg:account-ordering} Account: Ordering and Merging}
\end{algorithm}

The compare operation for account states $A$ and $A'$, written $A \leq_A  A'$, returns true if the state of account $A$ is smaller or equal than that of account $A'$. This is the case if and only if the set of identifiers for given and acknowledged tokens of $A$ are subsets of those $A'$ \textit{and} every counter of $A$ are smaller or equal to the corresponding counters in $A'$. Note that counters in $A'$ not present in $A$ have no effect. This enables comparing the state of two accounts to see if $A'$ is more up-to-date than $A$, in which case $A \leq_A  A'$, or if $A$ and $A'$ are the result of concurrent modifications, in which case both $A \nleq_A A'$ and $A' \nleq_A A$ (are false).

The merge operation between account states $A$ and $A'$, written $A'' = A \sqcup A'$, returns a new account state $A''$ that is the smallest state according to $\leq_A$ that is also larger than both $A$ and $A'$. It is implemented by 1) taking the union of all the keys (identifiers) on both $A_\rightarrow$ and $A'_\rightarrow$ into $A''_\rightarrow$, and similarly on $A_\leftarrow$ and $A'_\leftarrow$ into $A''_\leftarrow$; and 2) taking the maximum value of all internal counters if present on both $A$ and $A'$, otherwise either the value of $A$ or $A'$ whichever exists. This is useful, for example to update the state of a local replica so that it eventually incorporates all the changes that have happened on other remote replicas.

The account we just presented is a Conflict-Free Replicated Data Type~\cite{shapiro:hal-00932836} (Section~\ref{sec:proofs}) because all replicas are guaranteed to converge to the same state eventually. However, concurrent updates may result in a negative balance: \textit{e.g.}, two concurrent burn and give operations may have a sufficient balance to complete concurrently but together would compound after merging the state of replicas  (Figure~\ref{fig:account-negative-bal}).\footnote{Perhaps surprisingly, if there were no transfers, concurrent burns would never result in a negative balance because only the largest burnt amount, which was locally valid, would be retained instead of the sum of all burnt amounts. See the merge operation in Alg.~\ref{alg:account-ordering}.}. That being said, \textit{only concurrent updates} may result in a negative balance: if all updates are sequential, the sufficient balance pre-condition on all operations that decrease the balance (Alg.~\ref{alg:account}, line~\ref{ln:burn-balance-check} and \ref{ln:give-balance-check}) otherwise prevents the balance from going negative. We discuss some of the design dimensions available for system designers in Section~\ref{sec:design-neg-balance-choice}, that make the problem less of an issue than it might appear at first.

\begin{algorithm}
\begin{algorithmic}[1]
    \Function{$\sqcap_\mathds{A}$}{$A$, $A'$} \Comment{Call written in infix notation, \textit{e.g.}, $A \sqcap_\mathds{A}  A'$}
    	\If{$A_{\footnotesize \textbf{id}} \neq A'_{\footnotesize \textbf{id}}$}
		\textbf{error}
	\EndIf
	\State
        \State $A'' \leftarrow \texttt{initialize}(A_{\footnotesize \textbf{id}})$
        \State $A''_\uparrow \leftarrow \texttt{min}(A_\uparrow, A'_\uparrow)$
        \State $A''_\downarrow \leftarrow \texttt{min}(A_\downarrow, A'_\downarrow)$ 
	\For{$id ~\textbf{in}~ A_{\rightarrow *} \cap A_{\rightarrow *}'$} \Comment{Receiver ids}
		\State $A''_{\rightarrow}[id] \leftarrow \texttt{min}(A_{\rightarrow}[id], A'_{\rightarrow}[id])$
	\EndFor
	\For{$id ~\textbf{in}~ A_{\leftarrow *} \cap A_{\leftarrow *}'$} \Comment{Sender ids}
		\State $A''_{\leftarrow}[id] \leftarrow \texttt{min}(A_{\leftarrow}[id], A'_{\leftarrow}[id])$
	\EndFor
	\State \Return $A''$	
    \EndFunction
\end{algorithmic}
\caption{\label{alg:account-hlb} Account: Highest Lower Bound}
\end{algorithm}


\begin{figure}

\caption{Concurrent updates may lead to a negative account balance.}
\label{fig:account-negative-bal}
\end{figure}


\subsection{Ledger}
\label{sec:ledger}

Ledger replicas track the most up-to-date state of a set of accounts. They are essentially implemented as a grow-only dictionary of account replicas (Alg.~\ref{alg:ledger}), so the implementation of state and operations is straight-forward.

\begin{algorithm}
\begin{algorithmic}[1]
   \Function{initialize}{}
    	\State $L \leftarrow \{ \}$ \Comment{Dictionary of $\textit{id} \rightarrow \textit{accounts}$ }
    	\State \Return $L$
    \EndFunction
    \State
    \Function{add}{L, A}
        \State $L' \leftarrow \textit{copy}(L)$ \Comment{Deep copy}
    	\If{$A_{\scriptsize\textbf{id}} \notin L_*$}
		\State $L'[A_{\scriptsize\textbf{id}}] \leftarrow A$
	\Else
		\State $L'[A_{\scriptsize\textbf{id}}] \leftarrow L[A_{\scriptsize\textbf{id}}] \sqcup_A A$ \Comment{$\sqcup_A$ definition in Alg.~\ref{alg:account-ordering}}
	\EndIf
	\State \Return $L'$
    \EndFunction
    \State
    \Function{$\leq_\mathds{L}$}{$L$, $L'$} 
    	\State \Return $L_* \subseteq L'_* \wedge \bigwedge_{id \in L_*} L[id] \leq_A L'[id]$ \Comment{$\leq_A$ definition in Alg.~\ref{alg:account-ordering}}
    \EndFunction
    \State
    \Function{$\sqcup_\mathds{L}$}{$L$, $L'$}
        \State $L'' \leftarrow \texttt{initialize}()$
        \State $I \leftarrow L_* \cup L'_*$
	\For{$id ~\textbf{in}~ I$}
		\If{$id \in L_* \wedge id \in L'_*$}
			\State $L''[id] \leftarrow  L[id] \sqcup_A L'[id]$  \Comment{$\sqcup_A$ definition in Alg.~\ref{alg:account-ordering}}
		\ElsIf{$id \in L_*$}
			\State $L''[id] \leftarrow L[id]$
		\Else
			\State $L''[id] \leftarrow L'[id]$	
		\EndIf
	\EndFor
	\State \Return $L''$	
    \EndFunction
    \State
    \Function{balances}{L}
        \State \Return $\{~ (\textit{id}, \texttt{balance}(L[id])) \textbf{~for~} id ~\textbf{in}~ L_* ~\}$  \Comment{$L_*$ returns the set of ids in $L$}
    \EndFunction
\end{algorithmic}
\caption{\label{alg:ledger} Ledger}
\end{algorithm}

The \texttt{initialize} operation creates a new dictionary $L$ representing the ledger. The \texttt{balances} operation returns the balance of account replicas stored in $L$, in a new dictionary also indexed by account identifiers. 

The \texttt{add} operation adds a new account replica in $L$, returning a new dictionary $L'$. If account $A$ is not already present in $L$, it creates a new entry with a key corresponding to $A$'s identifier and the state of $A$ as a value. Otherwise, it merges the state of account $A$ with the state of the stored replica in $L$ with the same identifier, updating the ledger in the process.

The compare operation for ledger states $L$, and $L'$, written $L \leq_L L'$, returns true if the state of $L$ is smaller or equal than the state of $L'$. It does not modify the state of either $L$ or $L'$. The comparison is true if and only if, $L$ keys are a subset of keys in $L'$ and that every account associated to the keys ($id$s) in $L$ is smaller than the same account in $L'$, using the compare operation for accounts ($\leq_A$).

The merge operation between ledger states $L$ and $L'$, written $L'' = L \sqcup_L L'$, returns a new ledger state $L''$ that is the smallest state according to $\leq_L$ that is also larger than both $L$ and $L'$. It is implemented by taking 1) the union of all keys (identifiers) on both $L$ and $L'$ and 2) associating each keys to the most up-to-date corresponding account state. The second is implemented with the merge operation on accounts ($\sqcup_A$, Alg.~\ref{alg:account-ordering}) if the account is present in both states, otherwise it takes the state of the account either $L$ or $L'$, whichever is present.


This ledger design is also a Conflict-Free Replicated Data Type [1] (Section~\ref{sec:proofs}) because all replicas are guaranteed to converge to the same state eventually. To the exception of the possibility that accounts may have negative balance, there is no additional issue related to concurrency: any concurrent account updates will result in a valid ledger. Moreover, this is the case whichever design choices (Section~\ref{sec:design-issues}) are made regarding accounts.


\section{Design Dimensions}
\label{sec:design-issues}

In this section, we outline the design space for eventually-consistent ledgers. We sketch the general design directions but in all cases, we leave specific implementation details out to be covered in future papers.

\subsection{Who can create tokens?}

The design we presented, and the invariant we prove later, are compatible with different restrictions for token creation. For example:
\begin{itemize}
	\item \textit{All accounts}: The creation of a given token type may also be enabled for all accounts. However, this design point \textit{a priori} does not look interesting since any account might create an arbitrarily large amounts which would devalue all other tokens in circulation.
	\item \textit{Single account}: The creation of tokens can only be done by a single account, by linking the token type to the account identifier;
	\item \textit{Small number of accounts}: The creation of tokens can be done by a subset of accounts $\mathds{C} \subset \mathds{A}$, presumably with $\mathds{C}$ significantly smaller than $\mathds{A}$. This enables concurrent creation of tokens, maintaining liveness when some accounts might other otherwise be unavailable for updates.
\end{itemize}

It is possible to enforce that creation can happen only from a single or a small number of account using basic cryptographic primitives.

%In all cases, the same system may deal with multiple concurrent ledgers with different creators for each, so restrictions on the ability of most identifiers to create tokens in a given ledger do not prevent any identifier to create new tokens in other ledgers. Ultimately the value of any tokens created derives from the trust-worthiness of their creator and the willingness of users to accept them~\cite{lavoie2022localcryptotokens}.

\subsection{Can balances be temporarily negative?}
\label{sec:design-neg-balance-choice}

Depending on applications, the balance of all accounts might be required to stay strictly positive at all times or might be allowed to become negative during some concurrent updates. In both cases, the design we presented ensures that all replicas converge eventually to the same state, even if it is to a negative balance. In the next sections, we outline the impact on the rest of the design of either choice.

\subsubsection{The balance should be strictly positive at all times}

If \texttt{burn} or \texttt{giveTo} operations should never result in a negative balance, then state modifications to every account should be strictly sequential (see Theorem~\ref{proof:positive-bal-seq-order}). A sequential ordering may be obtained through different mechanisms:
\begin{itemize}
    \item \textit{Consensus}: Using some form of agreement protocol between replicas to order updates consistently;
    \item \textit{Master state}: By storing the latest state of the account on a single device (ex: usb key or hardware token) and requiring any replica to update it after every operation;
    \item \textit{Single replica}: By enforcing that modifications can only be issued by a unique replica (device). A physical person may still control multiple accounts but each account should be linked to a single replica.
\end{itemize}

Any other mechanism is also possible as long as no concurrent state updates are possible.

\subsubsection{The balance may be negative sometimes}

If \texttt{burn} or \texttt{giveTo} operations may sometimes result in a negative balance during concurrent updates, then general complementary strategies are still possible:
\begin{itemize}
	\item \textit{Allow updates with small amounts compared to the balance}: In that case, the probability that there would be a sufficient number of concurrent small updates that would result in a negative balance is small and therefore in most likelihood future merges will result in a positive balance. This approach increases \textit{availability} (liveness) of the system will limited additional complexity;
	\item \textit{De-incentivize with negative reputation}: For example, reporting the number of times and the cumulative negative account balance over the lifetime of an $id$ will alert other participants that the $id$, and associated accounts, are less trust-worthy than others and should be de-prioritized during exchanges. This approach increases the trust of users (\textit{safety}) in the system;
	\item \textit{Incentivize and even enforce a positive balance to participate}: For example, a platform using eventually-consistent ledgers may degrade and even refuse services to an identifier $id$ unless their associated account is positive;  This approach also increases the trust of users (\textit{safety}) in the system;
\end{itemize}

In all previous cases, the service should allow an account to receive additional tokens \textit{after} its balance became negative in order to restore its positive state. 

The failure to implement negative feedback mechanisms as above, without the ability to prevent account owners from spending more tokens than they have, would most likely result in the devaluation of all tokens and the lost of trust in the system. We therefore recommend implementing at least \textit{some} negative feedback mechanism.

\subsection{Who manages the replicas?}

\begin{itemize}
	\item \textit{A single organization} \textit{(centralized)}
	\item \textit{Multiple organizations}  \textit{(federated)}
	\item \textit{End-users} \textit{(peer-to-peer)}
\end{itemize}


\section{System Model}




\section{Related Work}

\subsection{Blockchains}

 In contrast to Bitcoin~\cite{bitcoin}, we decouple the sending and reception of tokens in a transaction: upon a \textit{give} operation, the balance of the sender is immediately decreased but the receiver balance is not immediately increased by the same amount.  The increase on the receiver side happens only  after an explicit \textit{acknowledgement}. 

Survey~\cite{weichao2018blockchain}

\subsection{Consensus-Free Ledgers} 

Gupta's Master thesis~\cite{gupta2016nonconsensusdft} is the earliest published work to our knowledge that describe a consensus-free ledger.

Astro~\cite{collins2020broadcast-payment} executes payment by broadcasting, using a Byzantine reliable broadcast in a permissioned setting showing the throughput and latency benefits of not using consensus because it is not actually need for asset transfer~\cite{guerraoui2021consensus}. 
Astro partitions replicas in shards among which Byzantine reliable broadcast is necessary but does not require agreement from all replicas because, similar to the property we leverage, the amount received from a payment need only be equal \textit{eventually} to the amount sent, the validity of the transfer only depends on the state of the sender. Astro uses exclusive logs (\textit{xlog}) that are equivalent to the single-writer append-only logs of Secure-Scuttlebutt (SSB)~\cite{kermarrec2020gossiping,tarr2019ssb} and Hypercore~\cite{hypercore-website} (see Section~\ref{sec:p2p-db}), whose designs was inspired by a reconciliation protocol~\cite{vanRenesse2008reconciliation} published by Amazon researchers in 2008. Astro prevents concurrent modifications of the same account by ordering transactions from the same sender with a Byzantine reliable broadcast among replicas. In contrast, our replicated ledger design does not prevent concurrent modifications but guarantees that all replicas will converge to the same (possibly negative) balance when they arise.

Fast-Pay~\cite{baudet2020fastpay} uses managed replicas, called authorities, to ensure sequential operations on every account and therefore remove the possibility of overspending. In contrast to our design, the creation (and destruction) of tokens is done externally to the Fast-Pay system by anchoring the payment system to an existing blockchain or centrally-managed database. Similar to Astro~\cite{collins2020broadcast-payment}, it shows that much lower latency and higher throughput are possible when carefully designing the system to avoid the need for consensus.

Auvolat \textit{et al.}~\cite{auvolat2021money} also obtain a consensus-free ledger by decoupling the aggregation of incoming and outgoing amounts as we do but define the core algorithms in terms of operations over a causal history, and explore the effects of the underlying broadcast channel, instead of our stateful formulation as a collection of grow-only counters. Our formulation removes the need to reason about causal histories and as all state-based CRDTs only require eventual delivery of the latest state instead of a reliable broadcast primitive.


ABC~\cite{sliwinski2020abc} is a proof-of-stake blockchain that does not require consensus, specifically relying instead on a weaker termination property that only guarantees termination of operations for honest (non double-spending) participants. The design is also based on an operation view that explicitly represents and store the operations as a directed-acyclic graph (DAG) of transactions, to determine the balance of participants. The state of the ledger for a given causal history, \textit{i.e.} DAG of transactions, can be derived as a \textit{checkpoint} to summarize the past and speed up validation.

Bezerra and Kuznetsov~\cite{bezerra2022tame}, instead of outright preventing overspending, bound the number of times the same tokens can be spent with verifiable evidence that the same tokens have been spent multiple times. They also suggest possible strategies once overspending has been detected.

Frey \textit{et al.}~\cite{frey:hal-03346756} show how Mazurkiewiczâs traces can be used to formalize ledgers in which operations between different processes commute but operations on the same process are sequential.

Permisionless and Asynchronous Asset Transfer: Pastro which work in an adversarial setting~\cite{kuznetsov2021permissionless} weighted quorums using stakes. Also implemented on top of reliable broadcast. Assumes a dynamic adversary.

Opportunistic Algorithmic Double-Spending~\cite{cryptoeprint:2021/1182}

Hearsay for Distributed Monetary System~\cite{georghiades2021needs}

Handling message semantics with generic broadcast protocols~\cite{pedone2002genericbroadcast}

Consensus number of a crypto-currency ~\cite{guerraoui2021consensus}

Cholvi \textit{et al.}~\cite{cholvi2021bdso} introduced Byzantine-Tolerant Replicated Grow-Only Sets to implement atomic appends in a ledger-like structure without the need for consensus, in an adversarial environment. Similar to other work on consensus-free ledgers, they base their semantics on broadcast abstractions while we base our account semantics on state-based CRDTs. This shows solutions in adversarial environments exists but finding simplest mechanisms that would still be compatible with our state-based approach is still an open problem.


In self-sovereign cryptocurrencies~\cite{shapiro2023sovereign}, Shapiro identifies general desirable economic properties of cryptocurrencies that can be issued and traded by anyone, people, communities, corporations, banks, municipalities and banks and provide a protocol that meets these properties. In complement, Lavoie and Tschudin~\cite{lavoie2022localcryptotokens} highlight that transactions costs in regular consensus-based blockchains, such as Bitcoin and Ethereum, are larger than many local economic applications can support, argue for eventual detection rather than prevention of over-spending, and identify potential applications. The design of our conflict-free replicated ledger is a step in the direction of cryptotokens that meet both, but would require additional mechanisms to be fault-tolerant in adversarial settings.


\subsection{Conflict-Free Replicated Data Types} 

Conflict-Free Replicated Data Types (CRDTs)~\cite{shapiro:hal-00932836} are replicated mutable objects that are designed to ensure converge to the same state \textit{eventually}, \textit{i.e.}, at some point in the future after updates have stopped, and \textit{automatically}, \textit{i.e.} using deterministic conflict-resolution rules in the presence of concurrent updates. An initial survey of useful data types~\cite{shapiro:inria-00555588} kickstarted the field, which has blossomed into over a hundred publications, as listed on a dedicated website~\cite{crdt-website}.

To our knowledge, there are no other published state-based conflict-free replicated ledgers, as listed on the aforementioned website~\cite{crdt-website}. That being said, the community exploring CRDTs seems to run parallel to the distributed computing community with slightly different, but ultimately connected, formalisms. For example, the designs presented in \cite{guerraoui2021consensus} and \cite{collins2020broadcast-payment} can be considered operation-based CRDTs since their operations commute, \textit{i.e.} the order in which transfers are received does not matter as long as they are delivered in their sending order. It appears the distributed computing community tends to favour an operation-based view and encapsulates the relevant properties into broadcast abstractions, as surveyed for example in this textbook~\cite{cachin2011introduction}, while the CRDT community explores both state-based and operation-based approaches.  


TODO: Delta-CRDT (see portfolio example)~\cite{Almeida2018delta}

\subsection{Consistency Models for Replicated Objects}

Viotti and  Vukoli\'{c} surveyed all major consistency models that have been proposed for operations on distributed objects up to 2016~\cite{viotti2016consistency-db-survey}, with formal definitions for each. They also relate all consistency models into a partial order, which helps highlight how the strong eventual consistency~\cite{shapiro:hal-00932836} approach taken by CRDTs, and used by our State-based Conflict-Free Replicated Ledger, runs parallel to most mother consistency models previously explored.

\subsection{Peer-to-Peer Eventually-Consistent Replicated Databases}
\label{sec:p2p-db}

The design we presented started as an exploration to implement a replicated ledger for Secure-Scuttlebutt (SSB)~\cite{kermarrec2020gossiping,tarr2019ssb}, an eventually consistent database based on single-writer append-only logs combined with peer-to-peer reconciliation protocols. The append-only logs provide a sequential ordering based on cryptographic hashes and signatures, which would be sufficient to maintain non-negative account balances. However, the reconciliation protocol of Secure-Scuttlebutt does not tolerate \textit{forks}, \textit{i.e.}, a concurrent message inserted at the same index in a log, potentially intentionally by a malicious participant in their own log, turns the log into a tree. In the presence of forks, replicas will only accept updates on the branch they initially started replicating and forever reject all others, which may result in an irreconcilable partitioning of replicas. Hypercore~\cite{hypercore-website}, previously known as DAT~\cite{ogden2017dat,robinson2018dat} and now maintained by Holepunch~\cite{holepunch-website}, is also an eventually consistent database based on single-writer append-only logs. It suffers from the same \textit{fork} issue~\cite{hypercore-handling-conflicts,hypercore-split-resolution-dep}  as SSB. Both designs are therefore not sufficient to implement our replicated ledger (and is not eventually consistent!) in an adversarial environment. Solving the fork issue in a peer-to-peer adversarial environment is still an open question.
 
\section{Future Work}
 
\subsection{Limiting the Creator Set}

\subsection{Tolerating Arbitrary Failures}

	\subsubsection{Collusion-Resistance}

\subsection{Limiting the Visibility of Transactions}

\subsection{Eventually-Consistent Reputation and Access-Control Mechanisms}

\subsection{Implementation Techniques for Resource-Limited Devices}

\section{Conclusion}
\label{sec:conclusion}

Implementation techniques for restricting token creation, which can potentially be based on cryptographic techniques, will be covered in future work.

\section{Acknowledgements}
\label{sec:acknowledgements}

We thank Christian F. Tschudin for fostering a research environment allowing detours and playfulness in the process, as well as providing financial support for this work and feedback on earlier versions of this work. The idea of investigating the possibilities offered by allowing accounts to converge to a negative balance in some circumstances was first suggested by him. Once the prejudice against negative balances was abandoned, that opened the possibility of expressing accounts as state-based CRDTs and greatly simplified the design.

I would also like to thank Prof. Dr. Tschudin for having initiated a CRDT seminar and invited me to co-teach it, which created the opportunity of learning how to formalize CRDT algorithms. I was initially planning to write a system paper on a similar design. However, after 6-7 design iterations, it became obvious that the design had subtleties that greatly benefitted from a more formal treatment to tease out and get right. The teaching of the CRDT seminar happened exactly at the right time to review fundamentals of distributed algorithms in general, and CRDTs in particular, to ramp up the skills to carry such work.



\newpage

\bibliographystyle{plainurl}
\bibliography{main}

\newpage
\appendix

\section{Proofs}
\label{sec:proofs}

\subsection{Definitions}

We first make the semantics of algorithms more precise with the following definitions:
\begin{proof}
	\begin{pfenum}
		\item $\mathds{R}^+$ is the set of real positive numbers, including zero.
		\item $\mathds{I}$ is the set of all possible identifiers.
		\item $\mathds{C} \subseteq \mathds{I}$ is the set of identifiers allowed to create tokens.
		\item $\mathds{D}$ is the set of all possible \textit{grow-only dictionaries of grow-only counters} indexed by identifiers, \textit{i.e.}, $\mathds{D}$ is the power set of the cartesian product of $\mathds{I}$ and $\mathds{R}$ ($\mathds{D} = \mathcal{P}(\mathds{I} \times \mathds{R}))$, with the additional constraint that for any $D \in \mathds{D}$ and any $(\textit{id},r)$ such that $\textit{id} \in \mathds{I}$ and $r \in \mathds{R}$, $id$ appears in at most one tuple in $D$.
		\item $D \leq_\mathds{D} D' \Leftrightarrow D_* \subseteq D'_* \wedge \bigwedge\limits_{id \in D_*} D[id] \leq D'[id] $
		\item $\mathds{A}$ is the set of all possible account states, \textit{i.e.}, $\mathds{A}$ is the cartesian product $\mathds{I} \times \mathds{R}^+ \times \mathds{R}^+ \times \mathds{D} \times \mathds{D}$, such that $(A_{\footnotesize \textbf{id}}, A_\uparrow, A_\downarrow, A_\rightarrow, A_\leftarrow) \in \mathds{A}$. 
		\item $\mathds{L}$ is the set of all possible ledger states, \textit{i.e.} the power set of the cartesian product of $\mathds{I}$ and $\mathds{A}$ ($\mathds{L} = \mathcal{P}(\mathds{I} \times \mathds{A})$) with the additional constraints that for any $L \in \mathds{L}$ and any $(\textit{id}, A) \in L$ $\textit{id} = A_{\footnotesize \textbf{id}}$ and \textit{id} appears in at most one tuple in $L$.
	\end{pfenum}
\end{proof}

Note that because all replicas converge to the same state does not mean that the balances on all replicas are guaranteed to always be positive for any possible concurrent operations. We therefore discuss safety properties related to the balance separately in Section~\ref{sec:proof:balance}.

\subsection{Lemmas}

\subsubsection{The composition of least upper bounds is a least upper bound.}
\label{sec:lemma:lub-composition}
 
\begin{proof}
	\assume{\begin{pfenum}
		\item $\mathds{A}$ and $\mathds{B}$ are sets
		\item Binary relations $\leq_\mathds{A}$ and $\leq_\mathds{B}$ define semi-lattices $\mathds{S}_\mathds{A}$ and $\mathds{S}_\mathds{B}$
		\item Equality $=$ relationship exists for $\mathds{A}$ and $\mathds{B}$
		\item $a <_\mathds{A} a' \Leftrightarrow a \leq_\mathds{A} \wedge~ a \neq a'$ and $b <_\mathds{B} b' \Leftrightarrow a \leq_\mathds{B} \wedge~ b \neq b'$
		\item Binary operators $\alpha$ and $\beta$ compute least upper bounds, respectively in $\mathds{S}_\mathds{A}$ and $\mathds{S}_\mathds{B}$
	\end{pfenum}}
	\define{\begin{pfenum}
		\item $\mathds{C} = \mathds{A} \times \mathds{B}$, \textit{i.e.} the cartesian product of $\mathds{A}$ and $\mathds{B}$ such that $C \in \mathds{C} \Rightarrow (C = (a,b)) \wedge a \in \mathds{A} \wedge b \in \mathds{B}$
		\item $C \leq_\mathds{C} C' \Leftrightarrow (a,b) \leq_\mathds{C} (a',b') \Leftrightarrow a \leq_\mathds{A} a' \wedge~ b \leq_\mathds{B} b'$ which defines a semi-lattice $\mathds{S}_\mathds{C}$
		\item $C = C'  \Leftrightarrow (a,b) = (a',b') \Leftrightarrow a = a' \wedge b = b'$
		\item $C <_\mathds{C} C'  \Leftrightarrow C \leq_\mathds{C} C' \wedge C \neq C'$
		\item $C ~\tau~ C' \Leftrightarrow (a,b)~\tau~(a',b') \Leftrightarrow (a~\alpha~a', b~\beta~b')$
	\end{pfenum}}
	\prove{$C''  = C ~\tau~ C'$ is the least upper bound of $C$ and $C'$ in $\mathds{S}_\mathds{C}$}
	

	\step{lbl:lub:def-1}{$C \leq_\mathds{C} C''$}
	\begin{proof}
		\step{}{$C'' = C ~\tau~ C' = (a,b) ~\tau~ (a',b') = (a ~\alpha~ a', b ~\beta~ b') = (a'', b'')$}
		\begin{proof}
			By definition.
		\end{proof}
		
		\step{lbl:lub:def-1:1}{$a \leq_\mathds{A} (a ~\alpha~ a') = a \leq_\mathds{A} a''$}
		\begin{proof}
			By assumption on $\alpha$ and the definition of least upper bound.
		\end{proof}
		
		
		\step{lbl:lub:def-1:2}{$b \leq_\mathds{B} (b ~\beta~ b') = b \leq_\mathds{B} b''$}
		\begin{proof}
			By assumption on $\beta$ and the definition of least upper bound.
		\end{proof}
		
		\qedstep
		\begin{proof}
			By \stepref{lbl:lub:def-1:1} and \stepref{lbl:lub:def-1:2} and definition.
		\end{proof}
	\end{proof}
		
	\step{lbl:lub:def-2}{$C' \leq_\mathds{C} C''$}
	\begin{proof}
		\textit{Idem} \stepref{lbl:lub:def-1} by replacing $C$ for $C'$.
	\end{proof}	
		
	\step{lbl:lub:def-3}{$\nexists C''' \in \mathds{C} : C \leq_\mathds{C} C''' \wedge C' \leq_\mathds{C} C''' \wedge C''' <_\mathds{C} C'' $}
	\begin{proof}
		\step{lbl:lub:def-3-1}{
			\assume{\begin{pfenum}
				\item $a \in \mathds{A}$
				\item $a' \in \mathds{A}$
				\item $a'' = a ~\alpha~ a'$
			\end{pfenum}}
			\prove{$\nexists a''' \in \mathds{A} : a \leq_\mathds{A} a''' \wedge a' \leq_\mathds{A} a''' \wedge a''' <_\mathds{A} a'' $}
			
			\pf~By assumption, because $\alpha$ computes a least upper bound.
		}
		
		\step{lbl:lub:def-3-2}{
			\assume{\begin{pfenum}
				\item $b \in \mathds{B}$
				\item $b' \in \mathds{B}$
				\item $b'' = b ~\beta~ b'$
			\end{pfenum}}
			\prove{$\nexists b''' \in \mathds{B} : b \leq_\mathds{B} b''' \wedge b' \leq_\mathds{B} b''' \wedge b''' <_\mathds{B} b'' $}
			
			\pf~By assumption, because $\beta$ computes a least upper bound.
		}
		
		\qedstep
		\begin{proof}
			By the conjunction of \stepref{lbl:lub:def-3-1} and \stepref{lbl:lub:def-3-2}, associativity of $\wedge$ and definitions.
		\end{proof}
	\end{proof}
		
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:lub:def-1}, \stepref{lbl:lub:def-2}, and \stepref{lbl:lub:def-3}, which is the definition of a least upper bound.
	\end{proof}
\end{proof}

\subsection{Convergence}

To establish convergence, we need to establish that the states of the design form a \textit{monotonic semi-lattice}~\cite{shapiro:hal-00932836}, which involves three propositions: First, that all possible ledger states can be organized in a semi-lattice $\mathds{S}_\mathds{L}$ ordered by $\leq_\mathds{L}$. This is a requisite for the next two properties. Second, that merging two ledger states $L$ and $L'$ computes the \textit{Least Upper Bound} (LUB) of $L$ and $L'$ in $\mathds{S}_\mathds{L}$. This ensures that the merge is \textit{commutative}, \textit{associative}, and \textit{idempotent}, providing \textit{safety}, \textit{i.e.}, that replicas will agree on the final state regardless of ordering, delays, or duplication of merge operations. Third, that all operations modify the state $L$ of a replica such that the new state $L'$ is either equal or larger than the previous state $L$ in $\mathds{S}_\mathds{L}$ (\textit{monotonicity}). This ensures all state changes will be eventually reflected in the new state of all replicas, either because the same update(s) will have concurrently been applied or because the new state will be the result of a merge. Assuming an underlying communication medium that ensures new states to be eventually delivered to other replicas, the three propositions combined ensure both \textit{liveness} and \textit{safety}: all state changes are going to be replicated on all replicas \textit{and} all replicas will agree on the final state automatically, i.e. \textit{strong eventual consistency}~\cite{shapiro:hal-00932836}.

Because an account state is the composition of \textit{grow-only counters} ($A_\uparrow$ and $A_\downarrow$) and \textit{grow-only dictionaries of grow-only counters}~\cite{lavoie2023statebased} ($A_\leftarrow$ and $A_\rightarrow$), and the ledger state is a \textit{grow-only dictionary of accounts}, the convergence proofs are straight-forward. We first prove that account replicas converge, then prove that ledgers converge as well. To make the proofs more accessible to practitioners and non-mathematicians, we follow the structured proof approach suggested by Lamport~\cite{lamport2012write}.

\subsubsection{Account}
\label{sec:proof:account}



\begin{proof}
        \prove{The Account design listed in Alg.~\ref{alg:account} and Alg.~\ref{alg:account-ordering} is a state-based (convergent) CRDT.}
	\pfsketch ~An account is the composition of state-based grow-only counters and grow-only dictionaries of grow-only counters. The three properties of \textit{ordering}, \textit{least upper bound}, and \textit{monotonicity} that are sufficient to define a state-based CRDT are the conjunction of corresponding properties on grow-only counters and grow-only dictionaries of grow-only counters.
\end{proof}

	
\begin{proof}
	\step{lbl:account:ordering}{
		\textbf{Ordering:} 
		Ordering $\mathds{A}$ by $\leq_\mathds{A}$ (Alg.~\ref{alg:account-ordering}) forms a semi-lattice $\mathds{S}_\mathds{A}$.
	}
	\begin{proof}
		\pfsketch~ $\leq_\mathds{A}$ is the conjunction of the $\subseteq$ and $\leq$ relationships, respectively forming partial orders on sets of identifiers in dictionaries in $\mathds{D}$ and real positive numbers $\mathds{R}^+$ that compose the possible states. Specifically:
		\begin{pfenum}
			\item $\leq$ creates partial orders on $A_\downarrow$ and $A_\uparrow$ counters (\textit{created} and \textit{burned} booleans).
			\item conjunction of $\subseteq$ on dictionary keys and $\leq$ on dictionary values creates partial orders on $A_\rightarrow$ and $A_\leftarrow$ dictionaries, (\textit{given} and \textit{acked} booleans).
			\item The conjunction of \textit{created}, \textit{burned}, \textit{given}, and \textit{acked} is also a partial order.
		\end{pfenum} 		
		Detailed proofs have already been published for grow-only counters of natural numbers, grow-only dictionaries of grow-only counters, and the conjunction of partial orders~\cite{lavoie2023statebased}. Those proofs apply directly to this proposition by replacing natural numbers by real numbers and adding a conjunction of dictionaries and grow-only counters.
	\end{proof}

	\step{lbl:account:lub}{
	        \textbf{Least Upper Bound:} 
		\assume{\begin{pfenum}
			\item $A \in \mathds{A}, A' \in \mathds{A}$
			\item \label{lbl:account:assumption:id} $A_{\footnotesize \textbf{id}} = A'_{\footnotesize \textbf{id}}$
		\end{pfenum}}
		
		\prove{$A'' = A \sqcup_\mathds{A} A'$ is the LUB of $A$ and $A'$ in $\mathds{S}_\mathds{A}$.}}

		\begin{proof}
			\step{lbl:account:lub:counter}{ $A''_\uparrow = \texttt{max}(A_\uparrow, A'_\uparrow)$ is the least upper bound of $A_\uparrow$ and $A'_\uparrow$ in the semi-lattice of real numbers $\mathds{S}_{\mathds{R}^+}$ formed by $\leq$. Idem for $A''_\downarrow = \texttt{max}(A_\downarrow, A'_\downarrow)$ in $\mathds{S}_{\mathds{R}^+}$.}
			\begin{proof}
				Same proof as in Annex of~\cite{lavoie2023statebased}, but on real numbers instead.
			\end{proof}
			
			\step{lbl:account:lub:dict}{$A''_{\leftarrow}$ is the least upper bound of $A_{\leftarrow}$ and $A'_{\leftarrow}$  in the semi-lattice of dictionaries $\mathds{S}_\mathds{D}$ formed by $\leq_\mathds{D}$. Idem for $A''_{\rightarrow }$ in $\mathds{S}_\mathds{D}$ formed by $\leq_\mathds{D}$.
			}
			\begin{proof}
				Same proof as for dictionaries in Annex of~\cite{lavoie2023statebased}: their \texttt{compare} method on dictionaries is defined similarly as the  \textit{given} and \textit{acked} conditions of $\leq_\mathds{A}$ in Alg.~\ref{alg:account-ordering}.
			\end{proof}
			
			\qedstep
			\begin{proof}
				By \stepref{lbl:account:lub:counter} and \stepref{lbl:account:lub:dict} and LUB composition lemma of Section~\ref{sec:lemma:lub-composition}.
			\end{proof}
		\end{proof}

	\step{lbl:account:monotonicity}{
	\textbf{Monotonicity:}
	All operations that may generate a new state, when applied on account state $A$ and any possible arguments, result in a new account state either equal or larger than $A$ in $\mathds{S}_\mathds{A}$ according to $\leq_\mathds{A}$.}
	
	\begin{proof}
		\step{}{\case{$A = \texttt{Initialize}(id)$}}
		\begin{proof}
			Initializes a new $A$ but not from an existing state, so monotonicity does not apply.
		\end{proof}
		
		\step{}{\case{$A' = \texttt{create}(A,\textit{amount})$}}
		\begin{proof}
			\step{}{\case{$A_{\footnotesize \textbf{id}} \in \mathds{C} \wedge \textit{amount} > 0$}}
			\begin{proof}
				$A'_\uparrow = A_\uparrow + \textit{amount} > A_\uparrow$ and all others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
			\end{proof}
			
			\step{}{\case{$A_{\footnotesize \textbf{id}} \notin \mathds{C} \vee \textit{amount} \leq 0$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{burn}(A,\textit{amount})$}}
		\begin{proof}
			\step{}{\case{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}}
			\begin{proof}
				$A'_\downarrow = A_\downarrow + \textit{amount} > A_\downarrow$ and all others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$. 
			\end{proof}
			
			\step{}{\case{$\textit{amount} \leq 0 \vee \texttt{balance}(A) < \textit{amount}$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{giveTo}(A,\textit{amount},\textit{id})$}}
		\begin{proof}
			\step{}{\case{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}}
			\begin{proof}
				\step{}{\case{$\textit{id} \notin A_\rightarrow [id]$}}
				\begin{proof}
					$A_{\rightarrow *} \cup \{ \textit{id} \} = A'_{\rightarrow *}$ therefore $A_{\rightarrow *} \subset A'_{\rightarrow *}$. All other properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof}
				
				\step{}{\case{$\textit{id} \in A_\rightarrow[id]$}}
				\begin{proof}
					$A_\rightarrow[id] + \textit{amount} = A'_\rightarrow[id]$ therefore $A_\rightarrow[id] < A'_\rightarrow[id]$. All others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof} 
			\end{proof}
			
			\step{}{\case{$\textit{amount} \leq 0 \vee \texttt{balance}(A) < \textit{amount}$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{ackFrom}(A,B)$}}
		\begin{proof}
			\step{}{\case{$A_{\scriptsize \textbf{id}} \in B_{\rightarrow *} \wedge \texttt{balance}(B) \geq 0$}}
			\begin{proof}
				\step{}{\case{$B_{\scriptsize \textbf{id}} \notin A_{\leftarrow *}$}}
				\begin{proof}
					$A_{\leftarrow *} \cup \{ B_{\scriptsize \textbf{id}} \} = A'_{\leftarrow *}$ therefore $A_{\leftarrow *} \subset A'_{\leftarrow *}$. All other properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof}
				
				\step{}{\case{$B_{\scriptsize \textbf{id}} \in A_{\leftarrow *}$}}
				\begin{proof}
					$A'_\leftarrow[B_{\scriptsize \textbf{id}}] = \texttt{max}(A_\leftarrow[B_{\scriptsize \textbf{id}}], B_\leftarrow[A_{\scriptsize \textbf{id}}])$ therefore $A_\leftarrow[B_{\scriptsize \textbf{id}}] \leq A'_\leftarrow[B_{\scriptsize \textbf{id}}]$. All others properties of $A'$ are equal to those of $A$, therefore $A \leq_\mathds{A} A'$.
				\end{proof} 
			\end{proof}
			
			\step{}{\case{$A_{\scriptsize \textbf{id}} \notin B_{\rightarrow *} \vee \texttt{balance}(B) < 0$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$b = \texttt{balance}(A)$}}
		\begin{proof}
			Does not modify the state of $A$.
		\end{proof}
		
		\step{}{\case{$b = \texttt{unackedFrom}(A,B)$}}
		\begin{proof}
			Does not modify the state of $A$.
		\end{proof}
		
		\step{}{\case{$b = A \leq_\mathds{A} A'$}}
		\begin{proof}
			Does not modify the state of $A$ or $A'$.
		\end{proof}
		
		\step{}{\case{$A'' = A \sqcup_\mathds{A} A'$}}
		\begin{proof}
			$A \leq_\mathds{A} A'' \wedge A' \leq_\mathds{A} A''$ because $\sqcup_\mathds{A}$ computes a LUB in $\mathds{S}_\mathds{A}$.
		\end{proof}
	\end{proof}
	
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:account:ordering}, \stepref{lbl:account:lub}, \stepref{lbl:account:monotonicity} which is the definition of a state-based CRDT.
	\end{proof}
\end{proof}


\subsubsection{Ledger}


\label{th:ledger-crdt}
\prove{The ledger of Algorithm~\ref{alg:ledger} is a state-based (convergent) conflict-free replicated data type.}
\begin{proof}
	\pfsketch~ The ledger is a grow-only dictionary of accounts, that are themselves state-based CRDTs.
	
	\step{lbl:ledger:ordering}{
		\textbf{Ordering:} 
		Ordering $\mathds{L}$ by $\leq_\mathds{L}$ (Alg.~\ref{alg:ledger}) forms a semi-lattice $\mathds{S}_\mathds{L}$.
	}
	\begin{proof}
		\pfsketch~ The ordering of $\mathds{L}$ is the conjunction the $\subseteq$ partial order on sets of identifiers that serve as dictionary keys, and $\leq_\mathds{A}$ on account states that serve as dictionary values. The proof is similar as for grow-only dictionaries of grow-only counters~\cite{lavoie2023statebased}.
	\end{proof}
	
	\step{lbl:ledger:lub}{
	        \textbf{Least Upper Bound:} 
		\assume{\begin{pfenum}
			\item $L \in \mathds{L}, L' \in \mathds{L}$
		\end{pfenum}}
		
		\prove{$L'' = L \sqcup_\mathds{L} L'$ is the LUB of $L$ and $L'$ in $\mathds{S}_\mathds{L}$.}}
	\begin{proof}		
		\step{lbl:ledger:lub:def-1}{$L \leq_\mathds{L} L''$}
		\begin{proof}
			\step{lbl:ledger:lub:def-1:1}{$L_* \subseteq L''_*$}
			\begin{proof}
				$L_* \subseteq (L_* \cup L'_*) = L''_*$.
			\end{proof}
			
			\step{lbl:ledger:lub:def-1:2}{$\forall_{\textit{id} \in L_*} L[\textit{id}] \leq_\mathds{A} L''[\textit{id}]$}
			\begin{proof}
				\step{lbl:ledger:lub:def-1:2:1}{\case{$\textit{id} \in L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$ L[\textit{id}] \leq_\mathds{A} L[\textit{id}] \sqcup_\mathds{A}  L'[\textit{id}]  = L''[\textit{id}]$
				\end{proof}
				
				\step{lbl:ledger:lub:def-1:2:2}{\case{$\textit{id} \in L_* \wedge \textit{id} \notin L'_*$}}
				\begin{proof}
					$L[\textit{id}] = L''[\textit{id}]$
				\end{proof}
			\end{proof}
			
			\qedstep
			\begin{proof}
				$\leq_\mathds{L}$ is the conjunction of \stepref{lbl:ledger:lub:def-1:1} and \stepref{lbl:ledger:lub:def-1:2}.
			\end{proof}
		\end{proof}
		
		\step{lbl:ledger:lub:def-2}{$L' \leq_\mathds{L} L''$}
		\begin{proof}
			\textit{Idem} \stepref{lbl:ledger:lub:def-1} on $L'$ instead of $L$.
		\end{proof}
		
		\step{lbl:ledger:lub:def-3}{$\nexists L''' \in \mathds{L} : L \leq_\mathds{L} L''' \wedge L' \leq_\mathds{L} L''' \wedge L''' <_\mathds{L} L''$}
		\begin{proof}
			\step{lbl:ledger:lub:def-3:ids}{It is not possible for $L_* \subseteq L'''_* \wedge L'_* \subseteq L'''_* \wedge L'''_* \subset L''_*$. }
			\begin{proof}
				$L''_* = L_* \cup L'_*$ is the least upper-bound of $L_*$ and $L'_*$ in $\mathds{S}_{\mathcal{P}(\mathds{I})}$ ordered by $\subseteq$ because $\cup$ computes the least upper bound on sets of identifiers (see \cite{lavoie2023statebased}).  
			\end{proof}
			
			\step{lbl:ledger:lub:def-3:accounts}{
				\assume{$L'''_* \subseteq L''_*$ (otherwise it is not possible for $L''' \leq_\mathds{L} L''$)}
				\prove{$\forall_{\textit{id} \in L'''_*}$, it is not possible for $L'''[\textit{id}]  <_\mathds{A} L''[\textit{id}]$ and $L[\textit{id}] \leq_\mathds{A} L'''[\textit{id}]$ (if $id \in L_*$) and $L'[\textit{id}] \leq_\mathds{A} L'''[\textit{id}]$  (if $id \in L'_*$)} }
			\begin{proof}
				\step{}{\case{$\textit{id} \in L_* \wedge \textit{id} \notin L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L[\textit{id}]$
				\end{proof}
				
				\step{}{\case{$\textit{id} \notin L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L'[\textit{id}]$
				\end{proof}
				
				\step{}{\case{$\textit{id} \in L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L[\textit{id}] \sqcup_\mathds{A} L'[\textit{id}] = \textit{LUB}(L[\textit{id}], L'[\textit{id}])$
				\end{proof}
			\end{proof}
			
			\qedstep
			\begin{proof}
				Because both \stepref{lbl:ledger:lub:def-3:ids} and \stepref{lbl:ledger:lub:def-3:accounts} are sufficient conditions (no other condition could make the proposition true). 
			\end{proof}
		\end{proof}
		
	
		\qedstep
		\begin{proof}
			The conjunction of \stepref{lbl:ledger:lub:def-1}, \stepref{lbl:ledger:lub:def-2}, \stepref{lbl:ledger:lub:def-3} is the definition of a least upper bound.
		\end{proof}
	\end{proof}

	\step{lbl:ledger:monotonicity}{		
	\textbf{Monotonicity:}
	All operations that may generate a new state, when applied on ledger state $L$ and any possible arguments, result in a new ledger state either equal or larger than $L$ in $\mathds{S}_\mathds{L}$ according to $\leq_\mathds{L}$.}
	\begin{proof}
		\step{}{\case{$L = \texttt{initialize}()$}}
		\begin{proof}
			Initializes a new $L$ but not from an existing state so monotonicity need not apply.
		\end{proof}
		
		\step{}{\case{$L' = \texttt{add}(L,A)$}}
		\begin{proof}
			\step{}{\case{$A_{\scriptsize \textbf{id}} \notin L_*$}}
			\begin{proof}
				$L_* \subset L_* \cup \{ A_{\scriptsize \textbf{id}} \} = L'_*$ and all dictionary values of $L$ are equal to those of $L'$.
			\end{proof}
			
			\step{}{\case{$A_{\scriptsize \textbf{id}} \in L_*$}}
			\begin{proof}
				$L_* = L'_*$, $L[A_{\scriptsize \textbf{id}}] \leq_\mathds{A} L[A_{\scriptsize \textbf{id}}] \sqcup_\mathds{A} A =  L'[A_{\scriptsize \textbf{id}}]$, and all other properties of $L'$ are equal to those of $L$.
			\end{proof}
		\end{proof}
			
		\step{}{\case{$b = L \leq_\mathds{L} L'$}}
		\begin{proof}
			Does not return a new ledger state so monotonicity need not apply.
		\end{proof}
			
		\step{}{\case{$L'' = L \sqcup_\mathds{L} L'$}}
		\begin{proof}
		 	By definition because $L''$ is a least upper bound (\stepref{lbl:ledger:lub}).
		\end{proof}
			
		\step{}{\case{$B = \texttt{balances}(L)$}}
		\begin{proof}
			Does not return a new ledger state so monotonicity need not apply.
		\end{proof}

	\end{proof}

	
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:ledger:ordering}, \stepref{lbl:ledger:lub}, \stepref{lbl:ledger:monotonicity} which is the definition of a state-based CRDT.
	\end{proof}
\end{proof}

\subsection{Highest Lower-Bound on Accounts}
\label{sec:hlb}

\assume{\begin{pfenum}
	\item $A_{\scriptsize \textbf{id}} \in \mathds{A}$
	\item $A'_{\scriptsize \textbf{id}} \in \mathds{A}$
	\item $A_{\scriptsize \textbf{id}} = A'_{\scriptsize \textbf{id}}$
\end{pfenum}}
\prove{\textbf{Highest Lower Bound:} $A'' = A \cap_\mathds{A} A'$ (Algorithm~\ref{alg:account-hlb}) is the highest lower bound of $A$ and $A'$ in $\mathds{S}_\mathds{A}$.}
\pfsketch~	The \texttt{minimum} function computes the upper least bound on numbers. The intersection ($\cap$) computes the upper least bound on sets of identifiers. The composition of highest least bounds is also a highest least bound on the cartesian products of domains (proof is similar to that for highest lower bound of Section~\ref{sec:lemma:lub-composition}). $\cap_\mathds{A}$ is a composition of \texttt{min} on grow-only counters an $\cap$ on sets of identifiers, therefore it also computes an upper least bound.
\begin{proof}
Alternatively a direct proof, using the definition of upper least bound:
	\step{lbl:hlb-1}{$A'' \leq_\mathds{A} A$}
	\begin{proof}
		\step{lbl:hlb-1-1}{$A''_\downarrow = \texttt{min}(A_\downarrow, A'_\downarrow) \leq A_\downarrow$ \newline
			   $A''_\uparrow = \texttt{min}(A_\uparrow, A'_\uparrow) \leq A_\uparrow$
		}
				
		\step{lbl:hlb-1-2}{$A''_{\leftarrow *} = A_{\leftarrow *} \cap A'_{\leftarrow *} \subseteq A_{\leftarrow *}$ \newline
			   $A''_{\rightarrow *} = A_{\rightarrow *} \cap A'_{\rightarrow *} \subseteq A_{\rightarrow *}$
		}
		
		\step{lbl:hlb-1-3}{
			\assume{\begin{pfenum}
				\item $id \in A_{\leftarrow *} \wedge id \in A'_{\leftarrow *}$
			\end{pfenum}}
			$A''_{\leftarrow}[id] = \texttt{min}(A_{\leftarrow}[id], A'_{\leftarrow}[id]) \leq A_{\leftarrow}[id]$
			
			\assume{\begin{pfenum}
				\item $id \in A_{\rightarrow *} \wedge id \in A'_{\rightarrow *}$
			\end{pfenum}}
			$A''_{\rightarrow}[id] = \texttt{min}(A_{\rightarrow}[id], A'_{\rightarrow}[id]) \leq A_{\rightarrow}[id]$
		}
		
		\qedstep
		\begin{proof}
			The five required conditions for $\leq_\mathds{A}$ to be true (Alg.~\ref{alg:account-ordering}) are satisfied by the followings:
			\begin{pfenum}
				\item By assumption $A_{\scriptsize \textbf{id}} = A'_{\scriptsize \textbf{id}}$;
				\item ($\textit{created}$) By \stepref{lbl:hlb-1-1};
				\item ($\textit{burned}$) By \stepref{lbl:hlb-1-1};
				\item ($\textit{given}$) By \stepref{lbl:hlb-1-2} and \stepref{lbl:hlb-1-3} for all $id \in A''_{\rightarrow *}$, the required assumption on \stepref{lbl:hlb-1-3} all satisfied because $A''_{\rightarrow *} = A_{\rightarrow *} \cap A'_{\rightarrow *}$;
				\item ($\textit{acked}$) Idem but on $A''_{\leftarrow *}$.
			\end{pfenum}
		\end{proof}
	\end{proof}
	
	\step{lbl:hlb-2}{$A'' \leq_\mathds{A} A'$}
	\begin{proof}
		Idem \stepref{lbl:hlb-1} but on $A'$ instead of $A$.
	\end{proof}
	
	\step{lbl:hlb-3}{$\nexists A''' \in \mathds{A} : A''' \leq_\mathds{A} A \wedge A''' \leq_\mathds{A} A' \wedge A'' <_\mathds{A} A'''$}
	\begin{proof}
		Assume by contradiction that such a $A'''$ exists. Therefore one or multiple of these conditions should be true (taken from Alg.~\ref{alg:account-ordering} and removing the equality case):
		\begin{pfenum}
			\item $A''_\uparrow < A'''_\uparrow$
			\item $A''_\downarrow < A'''_\downarrow$
			\item $A''_{\leftarrow *} \subset A'''_{\leftarrow *}$
			\item $\forall id \in A''_{\leftarrow *} : A''_{\leftarrow}[id] < A'''_{\leftarrow}[id] $
			\item $A''_{\rightarrow *} \subset A'''_{\rightarrow *}$  
			\item $\forall id \in A''_{\rightarrow *} : A''_{\rightarrow}[id] < A'''_{\rightarrow}[id] $
		\end{pfenum}
		However, for every number comparison ($<$) a larger value is not smaller than the corresponding values of $A$ and $A'$ because it is larger than either or both. Similarly, for set comparisons ($\subset$) a larger subset is smaller than the corresponding identifiers sets of $A$ and $A'$ because it is larger than either or both.
		
		Since none of the conditions above can be true, such a $A'''$ does not exist.
	\end{proof}
	
	\qedstep
	\begin{proof}
		The conjunction of \stepref{lbl:hlb-1}, \stepref{lbl:hlb-2}, and \stepref{lbl:hlb-3} is the definition of a highest lower bound.
	\end{proof}
\end{proof}



\subsection{Balance}
\label{sec:proof:balance}


\subsubsection{Sequences of Account Operations Maintain a Non-Negative Balance}


\assume{\begin{pfenum}
	\item $A,B \in \mathds{A}$
	\item $\texttt{balance}(A) \geq 0$
	\item $x \in \mathds{R}$
	\item $\textit{id} \in \mathds{I}$
	\item $\mathds{C}$ is the set of identifiers allowed to create tokens
\end{pfenum}}
\prove{For any sequence of operations on $A$ resulting in a new state $A'$, $\texttt{balance}(A') \geq 0$.}
\begin{proof}
\pfsketch~ By induction.
	For every case that modify the state of $A$, we list the properties that have changed between the original state of an account, and its following states marked with $'$, that influence the balance computation. Every non-listed properties stays the same.
		
	\step{seq:nn-bal:create}{\case{$A' = \texttt{create}(A,x)$}}
	\begin{proof}
		\step{}{\case{$A_{\scriptsize \textbf{id}} \in \mathds{C} \wedge x > 0$}}
		\begin{proof}
			\begin{pfenum}
				\item $A'_\uparrow = A_\uparrow + x$
				\item $\texttt{balance}(A') = \texttt{balance}(A) + x > 0$
			\end{pfenum}
		\end{proof}
		
		\step{}{\case{$A_{\scriptsize \textbf{id}} \notin \mathds{C} \vee x \leq 0$}}
		\begin{proof}
			\begin{pfenum}
				\item $A'_\uparrow = A_\uparrow$
				\item $\texttt{balance}(A') = \texttt{balance}(A) \geq 0$
			\end{pfenum}
		\end{proof}		
	\end{proof}
	
	\step{seq:nn-bal:burn}{\case{$A' = \texttt{burn}(A,x)$}}
	\begin{proof}
		\step{}{\case{$x > 0 \wedge \texttt{balance}(A) \geq x$}}
		\begin{proof}
			\begin{pfenum}
				\item $A'_\downarrow = A_\downarrow + x$
				\item $\texttt{balance}(A') = \texttt{balance}(A) - x \geq 0$
			\end{pfenum}
		\end{proof}
		
		\step{}{\case{$x \leq 0 \vee \texttt{balance}(A) < x$}}
		\begin{proof}
			\begin{pfenum}
				\item $A'_\downarrow = A_\downarrow$
				\item $\texttt{balance}(A') = \texttt{balance}(A) \geq 0$
			\end{pfenum}
		\end{proof}		
	\end{proof}
	
	\step{seq:nn-bal:giveTo}{\case{$A' = \texttt{giveTo}(A,x,\textit{id})$}}
	\begin{proof}
		\step{}{\case{$x > 0 \wedge \texttt{balance}(A) \geq x$}}
		\begin{proof}
			\step{}{\case{$id \notin A_{\rightarrow *}$}}
			\begin{proof}
				\begin{pfenum}
					\item $A'_{\rightarrow *} = A_{\rightarrow *} \cup \{ \textit{id} \}$
					\item $A'_\rightarrow [\textit{id}] = x$
					\item $\texttt{balance}(A') = \texttt{balance}(A) - x \geq 0$
				\end{pfenum}
			\end{proof}
			
			\step{}{\case{$id \in A_{\rightarrow *}$}}
			\begin{proof}
				\begin{pfenum}
					\item $A'_\rightarrow [\textit{id}] = A_\rightarrow [\textit{id}] + x$
					\item $\texttt{balance}(A') = \texttt{balance}(A) - x \geq 0$
				\end{pfenum}
			\end{proof}
		\end{proof}
		
		\step{}{\case{$x \leq 0 \vee \texttt{balance}(A) < x$}}
		\begin{proof}
			\begin{pfenum}
				\item $A'_\downarrow = A_\downarrow$
				\item $\texttt{balance}(A') = \texttt{balance}(A) \geq 0$
			\end{pfenum}
		\end{proof}		
	\end{proof}
	
	\step{seq:nn-bal:ackFrom}{\case{$A' = \texttt{ackFrom}(A,B)$}}
	\begin{proof}
		\step{}{\case{$A_{\scriptsize\textbf{id}} \in B_{\rightarrow *} \wedge \texttt{balance}(B) \geq 0$}}
		\begin{proof}
			\step{}{\case{$B_{\scriptsize\textbf{id}}  \notin A_{\leftarrow *}$}}
			\begin{proof}
				\begin{pfenum}
					\item $A'_{\leftarrow *} = A_{\leftarrow *} \cup \{ \textit{id} \}$
					\item $A'_\leftarrow [\textit{id}] = B_{\rightarrow}[A_{\scriptsize\textbf{id}}]$
					\item $\texttt{balance}(A') = \texttt{balance}(A) +  B_{\rightarrow}[A_{\scriptsize\textbf{id}}] \geq 0$, because only \texttt{giveTo} may have modified $B_{\rightarrow}[A_{\scriptsize\textbf{id}}]$ and only by increasing by a positive number. 
				\end{pfenum}
			\end{proof}
			
			\step{}{\case{$B_{\scriptsize\textbf{id}}  \in A_{\leftarrow *}$}}
			\begin{proof}
				\begin{pfenum}
					\item $A'_\leftarrow [\textit{id}] = \texttt{max}(A_\leftarrow [\textit{id}], B_{\rightarrow}[A_{\scriptsize\textbf{id}}])$
					\item $\texttt{balance}(A') = \texttt{balance}(A) +  \texttt{max}(A_\leftarrow [\textit{id}], B_{\rightarrow}[A_{\scriptsize\textbf{id}}]) \geq 0$, for the same reason as above.
				\end{pfenum}
			\end{proof}

			
		\end{proof}
		
		\step{}{\case{$A_{\scriptsize\textbf{id}} \notin B_{\rightarrow *} \vee \texttt{balance}(B) < 0$}}
		\begin{proof}
			\begin{pfenum}
				\item $A' = A$
				\item $\texttt{balance}(A') = \texttt{balance}(A) \geq 0$
			\end{pfenum}
		\end{proof}		
	\end{proof}

	\qedstep
	\begin{proof}
		Since \stepref{seq:nn-bal:create}, \stepref{seq:nn-bal:burn}, \stepref{seq:nn-bal:giveTo}, and \stepref{seq:nn-bal:ackFrom} maintain a non-negative balance for any possible inputs, any sequence of those operations also maintains a non-negative balance.
	\end{proof}
\end{proof}

\subsubsection{Merging Non-negative Accounts May Result in a Negative Balance}

\define{\begin{pfenum}
	\item $A \in \mathds{A} : \texttt{balance}(A) \geq 0$
	\item $A' \in \mathds{A} : \texttt{balance}(A') \geq 0$
	
	\item $\Delta_\downarrow \defeq   |A_\downarrow - A'_\downarrow| $
	\item $\Delta_\rightarrow \defeq    \sum\limits_{id \in A_{\rightarrow *} \cap A'_{\rightarrow *}} |A_{\rightarrow}[id]-A'_{\rightarrow}[id]| + \sum\limits_{id \in A_{\rightarrow *} \backslash A'_{\rightarrow *}}A_{\rightarrow}[id]  +  \sum\limits_{id \in A'_{\rightarrow *} \backslash A_{\rightarrow *}}A'_{\rightarrow}[id] $
	\item $\Delta_\uparrow \defeq   |A_\uparrow - A'_\uparrow| $
	\item $\Delta_\leftarrow \defeq    \sum\limits_{id \in A_{\leftarrow *} \cap A'_{\leftarrow *}} |A_{\leftarrow}[id]-A'_{\leftarrow}[id]| + \sum\limits_{id \in A_{\leftarrow *} \backslash A'_{\leftarrow *}}A_{\leftarrow}[id]  +  \sum\limits_{id \in A'_{\leftarrow *} \backslash A_{\leftarrow *}}A'_{\leftarrow}[id] $
\end{pfenum}}
\assume{$A_{\scriptsize \textbf{id}} = A'_{\scriptsize \textbf{id}}$}
\prove{$\texttt{balance}(A \sqcup_\mathds{A} A') < 0 \Leftrightarrow  \Delta_\downarrow  + \Delta_\rightarrow >  \Delta_\uparrow  + \Delta_\leftarrow + \texttt{balance}(A \sqcap_\mathds{A} A')$}
\begin{proof}

	\step{lbl:eq}{$\texttt{balance}(A \sqcup_\mathds{A} A') = \texttt{balance}(A \sqcap_\mathds{A} A') +  \Delta_\uparrow  + \Delta_\leftarrow  - \Delta_\downarrow  - \Delta_\rightarrow$}
	\begin{proof}
		\step{lbl:min-max-eq}{\assume{\begin{pfenum}
			\item $x,x' \in \mathds{R}$
		\end{pfenum}}
		\prove{$\texttt{max}(x,x') = \texttt{min}(x,x') + | x - x' |$}}
		\begin{proof}
			\step{lbl:3-1}{\case{$x > x'$}}
			\begin{proof}
				\step{}{$x = \texttt{min}(x,x') + | x - x' |$}
				\begin{proof}
					By assumption, therefore $\texttt{max}(x,x)' = x$.
				\end{proof}
				
				\step{}{$x = x' + | x - x' |$}
				\begin{proof}
					By assumption, therefore $\texttt{min}(x,x)' = x'$.
				\end{proof}
				
				\qedstep
				\begin{proof}
					Because $x - x' = | x - x' |$ and $x - x' > 0$.
				\end{proof}
			\end{proof}
			
			\step{lbl:3-2}{\case{$x < x'$}}
			\begin{proof}
				\step{}{$x' = \texttt{min}(x,x') + | x - x' |$}
				\begin{proof}
					By assumption, therefore $\texttt{max}(x,x)' = x'$.
				\end{proof}
				
				\step{}{$x' = x + | x - x' |$}
				\begin{proof}
					By assumption, therefore $\texttt{min}(x,x)' = x$.
				\end{proof}
				
				\qedstep
				\begin{proof}
					Because $x'-x = | x - x' |$ and $x' - x > 0$.
				\end{proof}
			\end{proof}
			
			\step{}{\case{$x = x'$}}
			\begin{proof}
				By replacing everything with $x$: $x = x + | x - x |$.
			\end{proof}
			
			\qedstep
			\begin{proof}
				No other cases and true for all of them.
			\end{proof}
		\end{proof}
		
		\step{}{\begin{pfenum}
			\item $\texttt{max}(A_\uparrow, A'_\uparrow) = \texttt{min}(A_\uparrow, A'_\uparrow) + | A_\uparrow - A'_\uparrow |$
			\item $\texttt{max}(A_\downarrow, A'_\downarrow) = \texttt{min}(A_\downarrow, A'_\downarrow) + | A_\downarrow - A'_\downarrow |$
		\end{pfenum}}
		\begin{proof}
			By replacing $x$ respectively with $A_\uparrow$ and $A_\downarrow$ in \stepref{lbl:min-max-eq}.
		\end{proof}
		
		\step{}{\assume{\begin{pfenum}
			\item $id \in A_{\leftarrow *} \wedge id \in A'_{\leftarrow *}$
		\end{pfenum}}
		\prove{\begin{pfenum}
			\item $\texttt{max}(A_{\leftarrow}[id],A'_{\leftarrow}[id]) = \texttt{min}(A_{\leftarrow}[id],A'_{\leftarrow}[id]) + | A_{\leftarrow}[id] - A'_{\leftarrow}[id] |$
			\item $\texttt{max}(A_{\rightarrow}[id],A'_{\rightarrow}[id]) = \texttt{min}(A_{\rightarrow}[id],A'_{\rightarrow}[id]) + | A_{\rightarrow}[id] - A'_{\rightarrow}[id] |$
		\end{pfenum}}}
		\begin{proof}
			By replacing $x$ respectively with $A_\leftarrow[id]$ and $A_\rightarrow[id]$ in \stepref{lbl:min-max-eq}.
		\end{proof}
		
		\step{}{\define{\begin{pfenum}
			\item $\textit{debits}_{A \sqcup_\mathds{A} A'} =
							\texttt{max}(A_\uparrow, A'_\uparrow) 
		                                         + \sum\limits_{id \in A_{\leftarrow *} \cap A'_{\leftarrow *}}\texttt{max}(A_{\leftarrow}[id], A'_{\leftarrow}[id]) 
		                                         \newline
		                                         + \sum\limits_{id \in A_{\leftarrow *} \backslash A'_{\leftarrow *}}A_{\leftarrow}[id] 
		                                         + \sum\limits_{id \in A'_{\leftarrow *} \backslash A_{\leftarrow *}}A'_{\leftarrow}[id] 
		                                         $
		         \item $\textit{credits}_{A \sqcup_\mathds{A} A'} =
							\texttt{max}(A_\downarrow, A'_\downarrow) 
		                                         + \sum\limits_{id \in A_{\rightarrow *} \cap A'_{\rightarrow *}}\texttt{max}(A_{\rightarrow}[id], A'_{\rightarrow}[id]) 
		                                         \newline
		                                         + \sum\limits_{id \in A_{\rightarrow *} \backslash A'_{\rightarrow *}}A_{\rightarrow}[id] 
		                                         + \sum\limits_{id \in A'_{\rightarrow *} \backslash A_{\rightarrow *}}A'_{\rightarrow}[id] 
		                                         $                             
			\end{pfenum}}
		\prove{
			$\texttt{balance}(A \sqcup_\mathds{A} A') = \textit{debits}_{A \sqcup_\mathds{A} A'}+ \textit{credits}_{A \sqcup_\mathds{A} A'}$
		}}
		\begin{proof}
			By definition of \texttt{balance} (Alg.~\ref{alg:account}) and $A \sqcup_\mathds{A} A'$ (Alg.~\ref{alg:account-ordering}).
		\end{proof}
		
		\step{}{\define{\begin{pfenum}
			\item $\textit{debits}_{A \sqcap_\mathds{A} A'} =
							\texttt{min}(A_\uparrow, A'_\uparrow) 
		                                         + \sum\limits_{id \in A_{\leftarrow *} \cap A'_{\leftarrow *}}\texttt{min}(A_{\leftarrow}[id], A'_{\leftarrow}[id])
		                                         $
		         \item $\textit{credits}_{A \sqcap_\mathds{A} A'} =
							\texttt{min}(A_\downarrow, A'_\downarrow) 
		                                         + \sum\limits_{id \in A_{\rightarrow *} \cap A'_{\rightarrow *}}\texttt{min}(A_{\rightarrow}[id], A'_{\rightarrow}[id]) 
		                                         $                             
			\end{pfenum}}
		\prove{
			$\texttt{balance}(A \sqcap_\mathds{A} A') = \textit{debits}_{A \sqcap_\mathds{A} A'}+ \textit{credits}_{A \sqcap_\mathds{A} A'}$
		}}
		\begin{proof}
			By definition of \texttt{balance} (Alg.~\ref{alg:account}) and $A \sqcap_\mathds{A} A'$ (Alg.~\ref{alg:account-hlb}).
		\end{proof}
		
		\qedstep
		\begin{proof}
			By the previous steps and rearranging terms according to the $\Delta$ definitions.
		\end{proof}                      
	\end{proof}

	\step{}{$\texttt{balance}(A \sqcup_\mathds{A} A') < 0 \Leftrightarrow  \texttt{balance}(A \sqcap_\mathds{A} A') + \Delta_\uparrow  + \Delta_\leftarrow - \Delta_\downarrow  - \Delta_\rightarrow < 0$}
	\begin{proof}
		By applying inequality to both sides of \stepref{lbl:eq}.
	\end{proof}
	
	\qedstep
	\begin{proof}
		By rearranging terms.	
	\end{proof}
\end{proof}

\subsubsection{Safety: Net Balance}

\define{\begin{pfenum}
	\item $\mathcal{L}$ is the set of all ledger replicas at any time
	\item $L =  \bigsqcup_\mathds{L} \mathcal{L}$ is the least upper bound on the state of replicas
	\item $\mathcal{A} = \{ L[id] : id \in L\}$ is the set of account states
	\item $\mathcal{C} = \{  A \in \mathcal{A} : A_{\scriptsize \textbf{id} \in \mathds{C}} \}$ are the accounts allowed to create tokens
	\item $\mathcal{A}^{\geq 0} = \{ A \in \mathcal{A} : \texttt{balance}(A) \geq 0 \} $ are the accounts with positive balances
	\item $\mathcal{A}^{< 0} = \{ A \in \mathcal{A} : \texttt{balance}(A) < 0 \} $ are the accounts with negative balances
\end{pfenum}}
\prove{
	$\sum\limits_{A \in \mathcal{A}^{\geq 0}} \texttt{balance}(A) \leq  
		\sum\limits_{C \in \mathcal{C}} C_\uparrow 
		- \sum\limits_{A \in \mathcal{A}} A_\downarrow 
		+ \sum\limits_{A \in \mathcal{A}^{< 0}}  -\texttt{balance}(A) $.}
\begin{proof}
	\step{}{$\sum\limits_{A \in \mathcal{A}} \texttt{balance}(A) \leq  
		\sum\limits_{C \in \mathcal{C}} C_\uparrow 
		- \sum\limits_{A \in \mathcal{A}} A_\downarrow$}
	\begin{proof}
		By sending  $\sum\limits_{A \in \mathcal{A}^{< 0}}  -\texttt{balance}(A)$ on the other side of the inequality, removing the double negation, and combining in a single summation.
	\end{proof}
	
	\step{}{$\sum\limits_{A \in \mathcal{A}} A_\uparrow
	 	   +\sum\limits_{A \in \mathcal{A}} \sum\limits_{id \in A_{\leftarrow}} A_\leftarrow[id]
		   -\sum\limits_{A \in \mathcal{A}} A_\downarrow
		   -\sum\limits_{A \in \mathcal{A}} \sum\limits_{id \in A_{\rightarrow}} A_\rightarrow[id] 
	 \leq  
		\sum\limits_{C \in \mathcal{C}} C_\uparrow 
		- \sum\limits_{A \in \mathcal{A}} A_\downarrow$}
	\begin{proof}
		By replacing \texttt{balance} by its definition.
	\end{proof}
	
	\step{lbl:sending-receiving-ineq-sums}{$
	 	\sum\limits_{A \in \mathcal{A}} \sum\limits_{id \in A_{\leftarrow}} A_\leftarrow[id]
	 \leq  
		\sum\limits_{A \in \mathcal{A}} \sum\limits_{id \in A_{\rightarrow}} A_\rightarrow[id] 
	 $}
	\begin{proof}
		Because $A_\uparrow = 0$ for all $A \notin \mathcal{C}$ and removing from both sides of the inequality. By removing $\sum\limits_{A \in \mathcal{A}} A_\downarrow$ from both sides of the inequality
	\end{proof}
	
		
	\step{lbl:sending-receiving-ineq-item}{For every pair of accounts $R,S \in \mathcal{A}$, $R_{\leftarrow}[S_{\scriptsize \textbf{id}}] \leq S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$ always.}
	\begin{proof}
		The only operation that modifies $R_{\leftarrow}$ is \texttt{ackFrom} and every update either uses the current value of $S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$, or the greatest of the previous value of  $R_{\leftarrow}[S_{\scriptsize \textbf{id}}]$, which can only be a previous value of  $S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$, and $S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$.
	\end{proof}
	
	\qedstep
	\begin{proof}
		Because \stepref{lbl:sending-receiving-ineq-item} is true for all pairs and $R_{\leftarrow}[S_{\scriptsize \textbf{id}}]$ exists only if $S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$, \stepref{lbl:sending-receiving-ineq-sums} is true, which connects to the proposition by doing the algebric manipulations above in reverse.
	\end{proof}
\end{proof}

\subsubsection{Liveness: Eventual Balance}

\define{~Same definitions as previous section.}
\prove{If no more \texttt{giveTo} operation is performed and every receiver account $R \in \mathds{A}$ eventually acknowledges all amounts sent by every sender account $S \in \mathds{A}$ (including $R=S$) with \texttt{ackFrom}, then eventually: \newline 
    $\sum\limits_{A \in \mathcal{A}^{\geq 0}} \texttt{balance}(A) =  
		\sum\limits_{C \in \mathcal{C}} C_\uparrow 
		- \sum\limits_{A \in \mathcal{A}} A_\downarrow 
		+ \sum\limits_{A \in \mathcal{A}^{< 0}}  -\texttt{balance}(A) $.}
\pf~ If all receiver accounts $R \in \mathcal{A}$ eventually acknowledge all amounts sent from sender accounts $S \in \mathcal{A}$ to $R$, then eventually $R_{\leftarrow}[S_{\scriptsize \textbf{id}}] = S_{\rightarrow}[R_{\scriptsize \textbf{id}}]$. This turns the inequality from the previous section into an equality.



\section{Notation and Conventions}
\label{apdx:notation}

We use notations and conventions that are good graphic mnemonics for the concepts and make the algorithms easier to reason about in the proofs (Section~\ref{sec:proofs}). The semantics are:

\begin{itemize}
	\item \textbf{Variables} are written in \textit{italic}:
		\begin{itemize}
			\item  lower case when containing literal values, ex: $id$;
			\item upper case when containing an object with multiple fields, a dictionary with multiple key-value pairs, or a set with multiple elements. For example, $A$ for account object, $L$ for a ledger dictionary, and $S$ for a set;
		\end{itemize}
	\item An \textbf{object's field} is accessed using a subscript, ex: $A$'s identifier stored in field $\textbf{id}$ is accessed $A_{\scriptsize \textbf{id}}$;
	\item An empty \textbf{dictionary} is written $\{\}$, accessing a dictionary $L$'s value stored under key $id$ is written $L[id]$, accessing all the keys of $L$ is written $L_*$;
	\item \textbf{Assigning} a new value to a variable, a field, or a dictionary entry uses $\leftarrow$, ex: $id \leftarrow id'$, $A_{\scriptsize\textbf{id}} \leftarrow id$, $L[id] \leftarrow A$. Variables, fields, and dictionaries are mutable and can be modified in place;
	 \item A \textbf{key-value} pair for dictionaries is written $\textit{key} \rightarrow \textit{value}$;
	 \item We use "dictionary-comprehension", similar to Python, for inline initialization fo dictionares, ex: ${ \textit{key} \rightarrow \textit{value} ~\textbf{for}~ \textit{key} ~\textbf{in}~ K }$;
	\item \textbf{Different states} for replicas of objects or dictionaries are written with $'$ and $''$ using the same variable name, ex: $A, A', A''$. We represent output values of functions using variable names with $'$ or $''$ to show they are later states of the same replica;
	\item The  \textbf{flow of tokens} on an account is suggested by the direction of an arrow used as a field name: 
		\begin{itemize}
			\item $A_\uparrow$ returns the number created tokens, which increases the account balance without transfers;
			\item $A_\downarrow$ returns the number of burned tokens, which decreases the account balance without transfers;
			\item $A_{\leftarrow}$ is a dictionary and $A_{\leftarrow}[id]$ returns the number of tokens received from $id$ and therefore flowing \textit{into} account $A$ (the arrow is a subscript to distinguish from assignment);
			\item $A_{\rightarrow}$ is a dictionary and $A_{\rightarrow}[id]$ returns the number of tokens given to $id$ therefore flowing \textit{out of} account $A$;
		\end{itemize}
\end{itemize}

Apart from these, we use common mathematical and pseudo-code conventions: 
\begin{itemize}
	\item $x \in X$ is an element $x$ in a set $X$ and $x \notin X$ means $x$ is not in a set $X$;
	\item $X \subseteq Y$ means $X$ is a subset of $Y$ which may include up to all elements of $Y$;
	 \item $\sum$ is a summation;
	 \item $\sum\limits_{x \in X} x$ is the sum of all elements in $X$;
	 \item $\leq$ is smaller or equal;
	 \item $\bigwedge$ and $\textbf{and}$ both represent a logical \textit{and};
	 \item $\bigwedge\limits_{x \in X} x$ is the logical and between all elements in $X$;
	 \item $\textbf{for}~x ~\textbf{in}~ X~\textbf{do}$ iterates over all values in $X$ sequentially assigning them to $x$.
\end{itemize}

%\section{Unused material}
%
%\begin{proof}
%	\assume{\begin{pfenum}
%		\item $A,B,C \in \mathds{A} \wedge A_{\scriptsize \textbf{id}} \in \mathds{C} \wedge  A_{\scriptsize \textbf{id}} \neq  B_{\scriptsize \textbf{id}}  \neq  C_{\scriptsize \textbf{id}} $
%		\item $\texttt{balance}(A) \geq 0 \wedge \texttt{balance}(B) \geq 0 \wedge \texttt{balance}(C) \geq 0$
%		\item $x,x' \in \mathds{R}^+ \wedge x > 0 \wedge x' > 0$
%	\end{pfenum}}
%\end{proof}
%
%For every case, we list the properties that have changed between the original state of an account, and its following states marked with $'$. Every non-listed properties stays the same. Except for transfers between accounts, we do not list most cases of sequential and concurrent updates on accounts with different identifiers, such as $A$ and $B$, because state updates are independent.
%
%
%\subsubsection{Sequences of Ledger Operations Maintain a Non-Negative Balance}
%
%\assume{\begin{pfenum}
%	\item $L \in \mathds{L}$
%	\item $\forall_{(id,b) \in \texttt{balances}(L)} b \geq 0$
%	\item $n \in \mathds{N}$
%\end{pfenum}}
%\define{\begin{pfenum}
%		\item $\textit{op}(L, id) \defeq \begin{cases}
%	        			\texttt{initialize$_\mathds{A}$}(id) :  id \notin L_*  \\
%				\texttt{create}(L[id], x) : x \in \mathds{R} \wedge id \in L_* \\
%				\texttt{burn}(L[id], x) : x \in \mathds{R} \wedge id \in L_* \\
%				\texttt{giveTo}(L[id], x, id') : x \in \mathds{R} \wedge id \in L_* \wedge id' \in \mathds{I} \\
%				\texttt{ackFrom}(L[id], L[id'],) :  id \in L_* \wedge id' \in L_*  \\
%			\end{cases}$
%		\item $\textit{Seq}(L, n) \defeq  \begin{cases}
%			n = 0 & L \\
%			n \geq 1 & \texttt{add}(L^{n-1}, op(L^{n-1})) :  L^{n-1} = \textit{Seq}(L, n-1)
%		\end{cases}$
%\end{pfenum}}
%\prove{For any sequence $L^n  = \textit{Seq}(L, n)$ such that $n \geq 1$, it is always true that \newline $\forall_{(id,b) \in \texttt{balances}(L^n)} b \geq 0$.}
%\begin{proof}
%	\pf~ 	
%\end{proof}
%
%
%
%
%\subsection{Causal history modeling}
%
%\define{\begin{pfenum}
%	\item $r : r \in \mathds{N} \wedge r \geq 2$ is the number of concurrent replicas
%	\item $L^0 \defeq \{ L^0_a : a \in [1,r] \wedge L^0_a \in \mathds{L} \}$ is the set of initial states of replicas
%	%\item $O : |O| \geq 0$ is the set of distinct states generated by local operations on replicas
%	%\item $M : |M| \geq r-1$ is the set of distinct states generated by merge operations between replicas
%	\item $T\defeq \{ L^i_a : L^i_a  \in \mathds{L} \wedge a \in [1,r] \wedge i~\text{is unique}~ \}$ is the set of states generated by intermediate transitions
%	\item $L^\top_a$ is the final state on replica $a$
%	\item $S \defeq L^0 \cup T \cup \{ L^\top_a \}$ is the set of causal states of $L^\top_a$
%	\item $\textit{transition} = \begin{cases}
%		L^i_a \anyop{op(id)} L^j_a                                                     & ~\text{if}~ L^j_a = \texttt{add}(L^i_a, op(L^i_a, id)) : L^i_a, L^j_a \in S \wedge \textit{id} \in \mathds{I} \\
%		L^i_a \mergeop L^k_a \wedge L^j_b \mergeop L^k_a     & ~\text{if}~ L^k_a = L^i_a \sqcup_\mathds{L} L^j_b : L^i_a, L^j_b, L^k_a \in S
%	\end{cases}$
%	\item $E \defeq \{ \textit{transition} \}$ 
%	\item $L^i_a \leadsto_E L^j_b$ means that there exists a sequence of $\rightarrow$ in $E$ from $L^i_a$ to $L^j_b$.
%	\item $L^i_a ~||_E~ L^j_b$ means that $L^i_a$ and $L^j_b$ are the result of concurrent transitions ($L^i_a \not \leadsto_E L^j_b$ and $L^j_b \not \leadsto_E L^i_a$).
%	\item $ L^i_a \anyop{\textit{credit}(id,x)} L^j_a \defeq \begin{cases}
%		\texttt{burn}(L^i_a[id],x) : \textit{id} \in \mathds{I} \wedge x \in \mathds{R} \\ 	
%		\texttt{giveTo}(L^i_a[id],x,id_2) :  \textit{id}, \textit{id}_2 \in \mathds{I} \wedge x \in \mathds{R} \\ 	
%	\end{cases}$
%
%\end{pfenum}}
%\assume{\begin{pfenum}
%	\item \textit{state crdt}: $L^k_a  \in S \Rightarrow L^k_a = \begin{cases} 
%		op(L^i_a, id) : L^i_a \in S \wedge i \neq k  ~\textit{(local operation)}\\ 
%		L^i_a \sqcup_\mathds{L} L^j_b : L^i_a, L^j_b \in S \wedge a \neq b \wedge i \neq k \wedge k \neq j ~\textit{(merge)}	
%	\end{cases}$
%	\item \textit{positive initial balance}: $\forall (id,b) \in \texttt{balances}(L^0_a) : L^0_a \in L^0 \Rightarrow b \geq 0$
%	\item \textit{causal history}: \begin{pfenum}
%		\item \textit{sequential replicas}: $L^i_a, L^j_a \in S \wedge j \neq i \Rightarrow L^i_a \leadsto L^j_a \vee L^j_a \leadsto L^j_a$
%		\item \textit{acyclic transitions}: $L^i_a \anyop{z} L^j_b \in E \Rightarrow   L^j_b \not \leadsto_E  L^i_a$
%		\item \textit{happen-before final state}: $L^j_b \in S \Rightarrow L^j_b \leadsto_E L^\top_a$	
%	\end{pfenum}
%\end{pfenum}}
%%\prove{For any execution $L^n = \textit{Conc}(L,n)$ such that $n \geq 1$, it is always true that $\forall_{(id,b) \in \texttt{balances}(L^n)} b \geq 0$.}
%
%
%
%%$ L^i_a \anyop{\textit{credit}_1(id,x)} L^j_a,  L^k_b \anyop{\textit{credit}_2(id,y)} L^l_b \in E $
% %                                $: \texttt{balance}((L^i_a \sqcup_\mathds{L} L^k_b)[id_1])) < x + y \wedge L^j_a ~||_E~ L^l_b$$
%
%
%\begin{proof}
%	\assume{\begin{pfenum}
%		\item $A,B,C \in \mathds{A} \wedge A_{\scriptsize \textbf{id}} \in \mathds{C} \wedge  A_{\scriptsize \textbf{id}} \neq  B_{\scriptsize \textbf{id}}  \neq  C_{\scriptsize \textbf{id}} $
%		\item $\texttt{balance}(A) \geq 0 \wedge \texttt{balance}(B) \geq 0 \wedge \texttt{balance}(C) \geq 0$
%		\item $x,x' \in \mathds{R}^+ \wedge x > 0 \wedge x' > 0$
%	\end{pfenum}}
%\end{proof}
%
%For every statement, we list the properties that have changed between the original state of an account, and its following states marked with $'$ and $''$. Every non-listed properties stays the same. Except for transfers between accounts, we do not list most cases of sequential and concurrent updates on accounts with different identifiers, such as $A$ and $B$, because state updates are independent.
%
%
%\textbf{Concurrent:}	
%\begin{proof}
%	\case{$\texttt{create} ~||~ \texttt{create}$}
%	\begin{proof}
%		\case{$(A' = \texttt{create}(A,x) ~||~ A'' = \texttt{create}(A,x')) \leadsto A''' = A' \sqcup_\mathds{A} A'' $}
%		\begin{proof}
%			\begin{pfenum}
%				\item $A'''_\uparrow = A_\uparrow + \texttt{max}(x,x')$
%				\item $\texttt{balance}(A''') = \texttt{balance}(A) + \texttt{max}(x,x') > 0$
%			\end{pfenum}
%		\end{proof}
%	\end{proof}
%	
%	\case{$\texttt{create} ~||~ \texttt{burn}$}
%	\begin{proof}
%		\case{$(A' = \texttt{create}(A,x) ~||~ A'' = \texttt{burn}(A,x')) \leadsto A''' = A' \sqcup_\mathds{A} A'' $}
%		\begin{proof}
%			\begin{pfenum}
%				\item $A'''_\uparrow = A'_\uparrow = A_\uparrow + x$
%			\end{pfenum}
%			
%			\case{$\texttt{balance}(A) \geq x'$}
%			\begin{proof}
%				\begin{pfenum}
%					\item $A'''_\downarrow = A''_\downarrow = A_\downarrow + x'$	
%					\item $\texttt{balance}(A''') = \texttt{balance}(A) + x - x'$	
%				\end{pfenum}
%				
%				\case{$\texttt{balance}(A) + x \geq x'$}
%				\begin{proof}
%					\begin{pfenum}
%						\item $\texttt{balance}(A''') \geq 0$
%					\end{pfenum}
%				\end{proof}
%				
%				\case{$\texttt{balance}(A) + x < x'$}
%				\begin{proof}
%					\begin{pfenum}
%						\item $\texttt{balance}(A''') < 0$
%					\end{pfenum}
%				\end{proof}
%			\end{proof}
%			
%			\case{$\texttt{balance}(A) < x'$}
%			\begin{proof}
%				\begin{pfenum}
%					\item $A'''_\downarrow = A''_\downarrow = A_\downarrow$	
%					\item $\texttt{balance}(A''') = \texttt{balance}(A) + x > 0$	
%				\end{pfenum}
%			\end{proof}
%			
%
%		\end{proof}
%	\end{proof}
%	
%	\case{$\texttt{create} ~||~ \texttt{giveTo}$}
%	
%	\case{$\texttt{create} ~||~ \texttt{ackFrom}$}
%	
%	\case{$\texttt{burn} ~||~ \texttt{burn}$}
%	
%	\case{$\texttt{burn} ~||~ \texttt{giveTo}$}
%	
%	\case{$\texttt{burn} ~||~ \texttt{ackFrom}$}
%	
%	\case{$\texttt{giveTo} ~||~ \texttt{giveTo}$}
%	
%	\case{$\texttt{giveTo} ~||~ \texttt{ackFrom}$}
%	
%	\case{$\texttt{ackFrom} ~||~ \texttt{ackFrom}$}
%	
%\end{proof}
%
%
%
%
%
%\subsubsection{Ledger Operations on Different Accounts (Sequential or Concurrent) Always Result in Non-Negative Balances}
%
%\define{\begin{pfenum}
%	\item $L^i \in \mathds{L} : (id, b) \in \texttt{balances}(L^i)  \Rightarrow b \geq 0$
%	\item $L^k \in \mathds{L} : (id, b) \in \texttt{balances}(L^k)  \Rightarrow b \geq 0$
%	\item $\textit{id}_1, \textit{id}_2 \in \mathds{I} : id_1 \neq id_2$
%	\item $L^j=\texttt{add}(L^i,op(L^i,id_1))$ 
%	\item $L^l=\texttt{add}(L^k,op(L^k,id_2))$
%\end{pfenum}}
%\assume{\begin{pfenum}
%	\item $ (id, b) \in \texttt{balances}(L^i \sqcup_\mathds{L} L^k)  \Rightarrow b \geq 0$
%\end{pfenum}}
%\prove{
%$ (id, b) \in \texttt{balances}(L^j \sqcup_\mathds{L} L^l)  \Rightarrow b \geq 0$}
%\pfsketch~ By case analysis. For all operations that never decrease the balance, this is trivially satisfied. For operations that may decrease the balance by an amount $x$ (\texttt{burn} and \texttt{giveTo}), the pre-condition that the balance is larger or equal to $x$ for the account to be modified guarantees that the resulting balance of the same account is non-negative. Finally, because balances of merged initial states are non-negative and both operations modify different accounts, both operations can be considered as independent sequential operation on their respective account that are going to be merged in the same ledger.
%
%
%\subsubsection{Concurrent Operations on the Same Account May Result in Negative Balance}
%
%\prove{Only concurrent \texttt{burn} and \texttt{giveTo} operations on different replicas for the same \textit{id} may result in negative balances. 
%
%Formally: \newline
% $  \exists L^i_a  \in S \wedge (id,b) \in \texttt{balances}(L^i_a) : b < 0 \Rightarrow $ \newline
% $ \exists L^i_a \anyop{\textit{credit}_1(id,x)} L^j_a,  L^k_b \anyop{\textit{credit}_2(id,y)} L^l_b \in E $
% $: \texttt{balance}((L^i_a \sqcup_\mathds{L} L^k_b)[id_1])) < x + y \wedge L^j_a ~||_E~ L^l_b$
%}
%
%%{If $\forall  L^j_a = op_1(L^i_a),  L^l_b = op_2(L^k_b) \in E$ such that $op_1$ and $op_2$ are \texttt{burn} or \texttt{giveTo} operations on the same $id$ and $L^j_a  ~\not{||_E}~ L^k_b$ then $\forall L^a_i \in S : (id,b) \in \texttt{balances}(L^a_i) : b \geq 0 $.}
%
%\begin{proof}
%	%$\begin{cases}
%	%	\textit{Seq}(L,n) \\
%	%	L' = \textit{Conc}(L,i) \leadsto \textit{Seq}(L',j) : i \geq 1 \wedge 	i + j = n \\
%	%	(L' = \textit{Conc}(L,i) ~||~ L'' =\textit{Conc}(L,k))  \leadsto L' \sqcup_\mathds{L} L'' : i \leq n-1 \wedge 0 \leq k \leq i
%	%\end{cases}$
%
%	\pfsketch~ All operations in \textit{Ops} only modify the state of a single account. This is true even for transferring tokens because the sending (\texttt{giveTo}) is decoupled from the reception (\texttt{ackFrom}). 
%\end{proof}

\end{document}  