\documentclass[9pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{hyperref}
\usepackage{doi}
\usepackage{pf2}

%\usepackage{amsthm}
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}{Lemma}



\title{Eventually-Consistent Ledgers}
\author{Erick Lavoie}
%\date{March, 13, 2023}							% Activate to display a given date or no 

\begin{document}
\maketitle


\begin{abstract}
It is commonly assumed that electronic asset transfers should require that the amount received in an account be exactly equal to the amount sent from another account \textit{immediately after every transaction}.  In this paper, we show instead that weaker invariants are sufficient to enable eventually-consistent electronic asset transfers, namely that 1) the positive contribution of a sender $S$ to a receiver $R$'s balance shall always be less or equal than the total amount ever sent by $S$ to $R$ and 2) the equality only needs to hold \textit{eventually}.

We present a state-based conflict-free replicated ledger leveraging these invariants and prove its convergence as well as the safety and liveness of the resulting account balances. We show that our design is sufficient in crash-stop, crash-recovery, and fail-silent system models. We finally highlight open challenges that arise in adversarial (Byzantine) settings. 

We envision applications using eventually-consistent ledgers to complement the existing financial and blockchain infrastructure by offering faster and more affordable small transactions between trusting parties, while the existing infrastructure will still be required for larger transactions between untrusting parties.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

\section{Eventually-Consistent Ledgers}

In this section, we present the design of eventually-consistent ledgers in two parts: we present eventually-consistent \textit{accounts} (Section~\ref{sec:account}) and then the eventually-consistent \textit{ledgers} proper (Section~\ref{sec:ledger}). We present the state and operations on both accounts and ledgers at a high-level to outline a \textit{family} of designs that are eventually-consistent: this will pave the way for a discussion of design dimensions (Section~\ref{sec:design-issues}) that can turn this high-level design into concrete implementations. Our notation and conventions are explained as they are introduced and collected in Appendix~\ref{apdx:notation}.

\subsection{Account}
\label{sec:account}

Account replicas track the current balance of tokens for a given owner identified by their \textit{identifier}, shorten as $id$. The state of an account is decomposed into multiple internal counters such that all counters are \textit{monotonically increasing}, \textit{i.e.}, every operation leaves counters either unchanged or larger. 

Before explaining what each internal counter represents, we give an overview of account operations. Each owner can  \textit{create} new tokens, if they have the capability; \textit{burn} tokens they own; and transfer some or all their tokens to other accounts, identified by different $id$s. This is similar to existing crypto-token designs, such as (CITE). In contrast to the previous examples, we split the transfer into two operations: the sender \textit{gives} tokens to a receiver account, which immediately decreases the balance of the sender; however, the balance of the receiver is only increased after an explicit \textit{acknowledgement}. This decomposition enables the reception of tokens to be tracked as a separate event: this allows, for example, other replicas to check if the receiver account has received (and accepted) the tokens.\footnote{It is possible to always automatically acknowledge the reception of tokens immediately upon reception and not expose the acknowledgment operation to the user. However, having the operation performed explicitly also gives the opportunity to the receiver to ignore tokens sent to them. We therefore prefer the explicit operation.} The implementation of operations follows from both principles, with each operation modifying separate internal counter(s). 

We first present the state and operations in the following section (Section~\ref{sec:account:state-operations}), and the ordering and merging operations necessary for concurrency, in the next (Section~\ref{sec:account:ordering-merging}).

\subsubsection{State and Operations}
\label{sec:account:state-operations}

The implementation of the state and corresponding operations is listed in Algorithm~\ref{alg:account}. 

\begin{algorithm}
\begin{algorithmic}[1]
   \State \textbf{Require} $\mathds{C}$, the set of identifiers allowed to create tokens
   \State
   \Function{initialize}{\textit{id}}
    	\State $A_{\scriptsize\textbf{id}} \leftarrow id$
	\State $A_\uparrow ~\leftarrow 0$       \Comment{Created amount (real positive number)}
	\State $A_\downarrow ~\leftarrow 0$   \Comment{Burned amount (real positive number)}
	\State $A_\rightarrow \leftarrow \{ \}$ \Comment{GivenTo: Dictionary of $\textit{id}$s associated to $\textit{amount}$s}
	\State $A_\leftarrow \leftarrow \{ \}$ \Comment{AckFrom: Dictionary of $\textit{id}$s associated to  $\textit{amount}$s}
    	\State \Return $A$
    \EndFunction
    \State
    \Function{create}{$A,\textit{amount}$} 
        \State $A'' \leftarrow \textit{copy}(A)$ \Comment{Deep copy}
    	\If{$A_{\scriptsize\textbf{id}} \in \mathds{C} \wedge \textit{amount} > 0$} 
		 \State $A''_\uparrow \leftarrow A_\uparrow + \textit{amount}$ 
	\EndIf
	\State \Return $A''$
    \EndFunction
    \State
     \Function{burn}{$A,\textit{amount}$}  
        \State $A'' \leftarrow \textit{copy}(A)$
    	\If{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$} \label{ln:burn-balance-check}
		 \State $A''_\downarrow \leftarrow A_\downarrow + \textit{amount}$ 
	\EndIf
	\State \Return $A''$
    \EndFunction
    \State
    \Function{giveTo}{$A,\textit{amount}, \textit{id}$}  
        \State $A'' \leftarrow \textit{copy}(A)$
    	\If{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}  \label{ln:give-balance-check}
		\If{$id \notin A_\rightarrow [id]$}
			\State $A''_{\rightarrow}[id] \leftarrow \textit{amount}$ 
		\Else
		         \State $A''_{\rightarrow}[id] \leftarrow A_{\rightarrow}[id] + \textit{amount}$ 
		\EndIf
	\EndIf
	\State \Return $A''$
    \EndFunction
    \State
    \Function{ackFrom}{$A, B$}
        \State $A'' \leftarrow \textit{copy}(A)$
        \If{$A_{\scriptsize\textbf{id}} \in B_{\rightarrow *} \wedge \texttt{balance}(B) \geq 0$}
		\If{$B_{\scriptsize\textbf{id}} \notin A_{\leftarrow *}$}
			 \State $A''_{\leftarrow}[B_{\scriptsize\textbf{id}}] \leftarrow B_{\rightarrow}[A_{\scriptsize\textbf{id}}]$
		\Else
			 \State $A''_{\leftarrow}[B_{\scriptsize\textbf{id}}] \leftarrow \texttt{max}(A_{\leftarrow}[B_{\scriptsize\textbf{id}}], B_{\rightarrow}[A_{\scriptsize\textbf{id}}])$ 
		\EndIf
        \EndIf
	\State \Return $A''$
    \EndFunction
    \State
        \Function{balance}{A}
        \State $\textit{debits} \leftarrow A_\uparrow + \sum\limits_{id \in A_{\leftarrow *}} A_{\leftarrow}[id]$ 
        \Comment{Keys of $A_\leftarrow$ written $A_{\leftarrow *}$}
        \State $\textit{credits} \leftarrow A_\downarrow + \sum\limits_{id \in A_{\rightarrow *}} A_{\rightarrow}[id]$
        \Comment{Keys of $A_\rightarrow$ written $A_{\rightarrow *}$}
        \State \Return $\textit{debits} - \textit{credits}$
    \EndFunction
    \State
    \Function{unackedFrom}{$A, B$}
        \State \Return $B_{\rightarrow A_{\tiny\textbf{id}}} - A_{\leftarrow B_{\tiny\textbf{id}}}$
    \EndFunction
    \end{algorithmic}
\caption{\label{alg:account} Account: State and Operations}
\end{algorithm}

A replica of an account belonging to owner $id$ is created with \texttt{initialize}. This initializes the internal identifier $A_{\textbf{id}}$ to $id$, the number of created tokens $A_\uparrow$ to $0$, the number of burned tokens $A_\downarrow$ to $0$, the dictionary of given tokens $A_\rightarrow$ to an empty dictionary, and the dictionary of acknowledged tokens $A_\leftarrow$ to an empty dictionary as well.\footnote{The left or right direction of the arrow notation suggests the corresponding direction of funds, respectively into or out from an account.}

The \texttt{create} operation takes the current state of an account $A$ and a requested \textit{amount} then returns a new state $A'$.\footnote{A practical implementation may actually encapsulate the state of an account in an object and modify it in place. We explicitly associate the different states to different variables to make the labels of the states in proofs (Section~\ref{sec:proofs}) easier to relate to the implementation.} Only allowed creators, \textit{i.e.}, those with ids within the set of allowed identifiers $\mathds{C}$, may create new tokens. The set of allowed creator identifiers might be distributed to replicas beforehand or enforced through cryptographic mechanisms. If the owner of the account has the necessary permission, the creation counter $A'_\uparrow$ is increased by \textit{amount}. This has the effect of increasing the balance of $A$ by \textit{amount}. Otherwise, the counter is unchanged ($A'_\uparrow=A_\uparrow$) and the balance remains the same.

The \texttt{burn} operation is similar to \texttt{create} with an opposite effect on the balance: it takes the current state of an account $A$ and a requested \textit{amount} to burn, then returns a new state $A'$. If the balance is equal or larger than \textit{amount}, the burn counter $A'_\downarrow$ is increased by \textit{amount}, and the balance correspondingly decreased by the same amount. Otherwise, $A'_\downarrow = A_\downarrow$. In contrast, to \texttt{create} any account is allowed to burn tokens. Restricting burning tokens to a set of identifiers would also be possible. However, the restriction would not be effective unless transfer operations were also restricted to only valid addresses,\footnote{Giving to an invalid or unused address effectively makes the tokens unavailable, similar to burning.} which in turn would require tracking the set of valid accounts. We therefore take the simpler and more open approach of allowing any account to burn tokens. 

The \texttt{giveTo} operation sends \textit{amount} tokens from account $A$ to the recipient account associated to $id$, resulting in a new state $A'$. The account state tracks the total amount ever sent to $id$ using the dictionary $A_{\rightarrow}$, using $id$ as a key to access the associated monotonic counter, written $A_{\rightarrow}[id]$. This counter is only increased if the local balance is higher or equal than the \textit{amount} sent.

The \texttt{ackFrom} operation acknowledges the reception of tokens from account $B$ by account $A$, resulting in new state $A'$. The implementation simply takes the maximum value of the tokens sent $B_{\rightarrow A_{\tiny \textbf{id}}}$ and the previously acknowledged tokens $A_{\leftarrow B_{\tiny \textbf{id}}}$. At all times the former is equal or larger than the latter.

The \texttt{balance} of an account $A$ performs additions and subtractions on counters corresponding to individual operations to compute the total balance of an account. It does not modify the state of the account. The implementation first computes the \textit{debits}, \textit{i.e.}, the sum of the amounts that increase the balance: that corresponds to the number of created tokens and the sum of the tokens acknowledged from all other accounts. Second, it computes the \textit{credits}, \textit{i.e.}, the sum of the amounts that decrease the balance: that corresponds to the number of tokens burnt and the sum of tokens given to all other accounts. The total is the difference between the \textit{debits} and the \textit{credits}.

The last operation, \texttt{unackedFrom} computes the sum of tokens sent from account $B$ that have not yet been acknowledged by account $A$. It does not modifies the state of $A$ nor $B$. This is implemented by subtracting the tokens acknowledged by $A$ from $B$, from the tokens sent by $B$ to $A$. If the result is greater than zero, there are unacknowledged tokens.

\subsubsection{Ordering and Merging}
\label{sec:account:ordering-merging}

The next two operations, shown in Algorithm~\ref{alg:account-ordering}, respectively establish a partial order between the different states of replicas, and enable merging different states, possibly modified concurrently, to obtain a new state.

\begin{algorithm}
\begin{algorithmic}[1]
    \Function{$\leq_\mathds{A}$}{$A$, $A'$} \Comment{Compare, call written in infix notation, \textit{e.g.}, $A \leq_\mathds{A}  A'$}
        \State $\textit{created} \leftarrow A_\uparrow \leq A'_\uparrow$
        \State $\textit{burned} \leftarrow A_\downarrow \leq A'_\downarrow$
        \State $\textit{given} \leftarrow A_{\rightarrow *} \subseteq A'_{\rightarrow *} \wedge \bigwedge\limits_{id \in A_{\rightarrow *}} A_{\rightarrow}[id] \leq A'_{\rightarrow}[id]$ \Comment{Keys of $A_\rightarrow$ written $A_{\rightarrow *}$}
        \State $\textit{acked} \leftarrow A_{\leftarrow *} \subseteq A'_{\leftarrow *} \wedge \bigwedge\limits_{id \in A_{\leftarrow *}} A_{\leftarrow}[id] \leq A'_{\leftarrow}[id]$
        \State \Return $A_{\footnotesize \textbf{id}} = A'_{\footnotesize \textbf{id}} \wedge \textit{created} \wedge \textit{burned} \wedge \textit{given} \wedge \textit{acked}$
    \EndFunction
    \State
    \Function{$\sqcup_\mathds{A}$}{$A$, $A'$} \Comment{Merge, call written in infix notation, \textit{e.g.}, $A \sqcup_\mathds{A}  A'$}
        \State $A'' \leftarrow \texttt{initialize}(A_{\footnotesize \textbf{id}})$ \Comment{Assume $A_{\footnotesize \textbf{id}} = A'_{\footnotesize \textbf{id}}$}
        \State $A''_\uparrow \leftarrow \texttt{max}(A_\uparrow, A'_\uparrow)$
        \State $A''_\downarrow \leftarrow \texttt{max}(A_\downarrow, A'_\downarrow)$ 
        \State
        \State $R \leftarrow A_{\rightarrow *} \cup A_{\rightarrow *}'$ \Comment{Receiver ids}
	\For{$id ~\textbf{in}~ R$}
		\If{$id \in A_{\rightarrow *} \wedge id \in A'_{\rightarrow *} $}
			\State $A''_{\rightarrow}[id] \leftarrow \texttt{max}(A_{\rightarrow}[id], A'_{\rightarrow}[id])$
		\ElsIf{$id \in A_{\rightarrow *}$}
			\State $A''_{\rightarrow}[id] \leftarrow A_{\rightarrow}[id]$
		\Else
			\State $A''_{\rightarrow}[id] \leftarrow A'_{\rightarrow}[id]$
		\EndIf
	\EndFor
	\State
	\State $S \leftarrow A_{\leftarrow *} \cup A_{\leftarrow *}'$ \Comment{Sender ids}
	\For{$id ~\textbf{in}~ A'_{\leftarrow *}$}
		\If{$id \in A_{\leftarrow *} \wedge id \in A_{\leftarrow *}'$}
			\State $A''_{\leftarrow}[id] \leftarrow \texttt{max}(A_{\leftarrow}[id], A'_{\leftarrow}[id])$
		\ElsIf{$id \in A_{\leftarrow *}$}
			\State $A''_{\leftarrow}[id] \leftarrow A_{\leftarrow}[id]$
		\Else
			\State $A''_{\leftarrow}[id] \leftarrow A'_{\leftarrow}[id]$
		\EndIf
	\EndFor
	\State
	\State \Return $A''$	
    \EndFunction
\end{algorithmic}
\caption{\label{alg:account-ordering} Account: Ordering and Merging}
\end{algorithm}

The compare operation for account states $A$ and $A'$, written $A \leq_A  A'$, returns true if the state of account $A$ is smaller or equal than that of account $A'$. This is the case if and only if the set of identifiers for given and acknowledged tokens of $A$ are subsets of those $A'$ \textit{and} every counter of $A$ are smaller or equal to the corresponding counters in $A'$. Note that counters in $A'$ not present in $A$ have no effect. This enables comparing the state of two accounts to see if $A'$ is more up-to-date than $A$, in which case $A \leq_A  A'$, or if $A$ and $A'$ are the result of concurrent modifications, in which case both $A \nleq_A A'$ and $A' \nleq_A A$ (are false).

The merge operation between account states $A$ and $A'$, written $A'' = A \sqcup A'$, returns a new account state $A''$ that is the smallest state according to $\leq_A$ that is also larger than both $A$ and $A'$. It is implemented by 1) taking the union of all the keys (identifiers) on both $A_\rightarrow$ and $A'_\rightarrow$ into $A''_\rightarrow$, and similarly on $A_\leftarrow$ and $A'_\leftarrow$ into $A''_\leftarrow$; and 2) taking the maximum value of all internal counters if present on both $A$ and $A'$, otherwise either the value of $A$ or $A'$ whichever exists. This is useful, for example to update the state of a local replica so that it eventually incorporates all the changes that have happened on other remote replicas.

The account we just presented is a Conflict-Free Replicated Data Type~\cite{shapiro:hal-00932836} (Section~\ref{sec:proofs}) because all replicas are guaranteed to converge to the same state eventually. However, concurrent updates may result in a negative balance: \textit{e.g.}, two concurrent burn and give operations may have a sufficient balance to complete concurrently but together would compound after merging the state of replicas  (Figure~\ref{fig:account-negative-bal}).\footnote{Perhaps surprisingly, if there were no transfers, concurrent burns would never result in a negative balance because only the largest burnt amount, which was locally valid, would be retained instead of the sum of all burnt amounts. See the merge operation in Alg.~\ref{alg:account-ordering}.}. That being said, \textit{only concurrent updates} may result in a negative balance: if all updates are sequential, the sufficient balance pre-condition on all operations that decrease the balance (Alg.~\ref{alg:account}, line~\ref{ln:burn-balance-check} and \ref{ln:give-balance-check}) otherwise prevents the balance from going negative. We discuss some of the design dimensions available for system designers in Section~\ref{sec:design-neg-balance-choice}, that make the problem less of an issue than it might appear at first.


\begin{figure}

\caption{Concurrent updates may lead to a negative account balance.}
\label{fig:account-negative-bal}
\end{figure}


\subsection{Ledger}
\label{sec:ledger}

Ledger replicas track the most up-to-date state of a set of accounts. They are essentially implemented as a grow-only dictionary of account replicas (Alg.~\ref{alg:ledger}), so the implementation of state and operations is straight-forward.

\begin{algorithm}
\begin{algorithmic}[1]
   \Function{initialize}{}
    	\State $L \leftarrow \{ \}$ \Comment{Dictionary of $\textit{id} \rightarrow \textit{accounts}$ }
    	\State \Return $L$
    \EndFunction
    \State
    \Function{add}{L, A}
        \State $L' \leftarrow \textit{copy}(L)$ \Comment{Deep copy}
    	\If{$A_{\scriptsize\textbf{id}} \notin L_*$}
		\State $L'[A_{\scriptsize\textbf{id}}] \leftarrow A$
	\Else
		\State $L'[A_{\scriptsize\textbf{id}}] \leftarrow L[A_{\scriptsize\textbf{id}}] \sqcup_A A$ \Comment{$\sqcup_A$ definition in Alg.~\ref{alg:account-ordering}}
	\EndIf
	\State \Return $L'$
    \EndFunction
    \State
    \Function{$\leq_\mathds{L}$}{$L$, $L'$} 
    	\State \Return $L_* \subseteq L'_* \wedge \bigwedge_{id \in L_*} L[id] \leq_A L'[id]$ \Comment{$\leq_A$ definition in Alg.~\ref{alg:account-ordering}}
    \EndFunction
    \State
    \Function{$\sqcup_\mathds{L}$}{$L$, $L'$}
        \State $L'' \leftarrow \texttt{initialize}()$
        \State $I \leftarrow L_* \cup L'_*$
	\For{$id ~\textbf{in}~ I$}
		\If{$id \in L_* \wedge id \in L'_*$}
			\State $L''[id] \leftarrow  L[id] \sqcup_A L'[id]$  \Comment{$\sqcup_A$ definition in Alg.~\ref{alg:account-ordering}}
		\ElsIf{$id \in L_*$}
			\State $L''[id] \leftarrow L[id]$
		\Else
			\State $L''[id] \leftarrow L'[id]$	
		\EndIf
	\EndFor
	\State \Return $L''$	
    \EndFunction
    \State
    \Function{balances}{L}
        \State \Return $\{~ id \rightarrow \texttt{balance}(L[id]) \textbf{~for~} id ~\textbf{in}~ L_* ~\}$  \Comment{$L_*$ returns the set of ids in $L$}
    \EndFunction
\end{algorithmic}
\caption{\label{alg:ledger} Ledger}
\end{algorithm}

The \texttt{initialize} operation creates a new dictionary $L$ representing the ledger. The \texttt{balances} operation returns the balance of account replicas stored in $L$, in a new dictionary also indexed by account identifiers. 

The \texttt{add} operation adds a new account replica in $L$, returning a new dictionary $L'$. If account $A$ is not already present in $L$, it creates a new entry with a key corresponding to $A$'s identifier and the state of $A$ as a value. Otherwise, it merges the state of account $A$ with the state of the stored replica in $L$ with the same identifier, updating the ledger in the process.

The compare operation for ledger states $L$, and $L'$, written $L \leq_L L'$, returns true if the state of $L$ is smaller or equal than the state of $L'$. It does not modify the state of either $L$ or $L'$. The comparison is true if and only if, $L$ keys are a subset of keys in $L'$ and that every account associated to the keys ($id$s) in $L$ is smaller than the same account in $L'$, using the compare operation for accounts ($\leq_A$).

The merge operation between ledger states $L$ and $L'$, written $L'' = L \sqcup_L L'$, returns a new ledger state $L''$ that is the smallest state according to $\leq_L$ that is also larger than both $L$ and $L'$. It is implemented by taking 1) the union of all keys (identifiers) on both $L$ and $L'$ and 2) associating each keys to the most up-to-date corresponding account state. The second is implemented with the merge operation on accounts ($\sqcup_A$, Alg.~\ref{alg:account-ordering}) if the account is present in both states, otherwise it takes the state of the account either $L$ or $L'$, whichever is present.


This ledger design is also a Conflict-Free Replicated Data Type [1] (Section~\ref{sec:proofs}) because all replicas are guaranteed to converge to the same state eventually. To the exception of the possibility that accounts may have negative balance, there is no additional issue related to concurrency: any concurrent account updates will result in a valid ledger. Moreover, this is the case whichever design choices (Section~\ref{sec:design-issues}) are made regarding accounts.


\section{Design Dimensions}
\label{sec:design-issues}

In this section, we outline the design space for eventually-consistent ledgers. We sketch the general design directions but in all cases, we leave specific implementation details out to be covered in future papers.

\subsection{Who can create tokens?}

The design we presented, and the invariant we prove later, are compatible with different restrictions for token creation. For example:
\begin{itemize}
	\item \textit{All accounts}: The creation of a given token type may also be enabled for all accounts. However, this design point \textit{a priori} does not look interesting since any account might create an arbitrarily large amounts which would devalue all other tokens in circulation.
	\item \textit{Single account}: The creation of tokens can only be done by a single account, by linking the token type to the account identifier;
	\item \textit{Small number of accounts}: The creation of tokens can be done by a subset of accounts $\mathds{C} \subset \mathds{A}$, presumably with $\mathds{C}$ significantly smaller than $\mathds{A}$. This enables concurrent creation of tokens, maintaining liveness when some accounts might other otherwise be unavailable for updates.
\end{itemize}

It is possible to enforce that creation can happen only from a single or a small number of account using basic cryptographic primitives.

%In all cases, the same system may deal with multiple concurrent ledgers with different creators for each, so restrictions on the ability of most identifiers to create tokens in a given ledger do not prevent any identifier to create new tokens in other ledgers. Ultimately the value of any tokens created derives from the trust-worthiness of their creator and the willingness of users to accept them~\cite{lavoie2022localcryptotokens}.

\subsection{Can balances be temporarily negative?}
\label{sec:design-neg-balance-choice}

Depending on applications, the balance of all accounts might be required to stay strictly positive at all times or might be allowed to become negative during some concurrent updates. In both cases, the design we presented ensures that all replicas converge eventually to the same state, even if it is to a negative balance. In the next sections, we outline the impact on the rest of the design of either choice.

\subsubsection{The balance should be strictly positive at all times}

If \texttt{burn} or \texttt{giveTo} operations should never result in a negative balance, then state modifications to every account should be strictly sequential (see Theorem~\ref{proof:positive-bal-seq-order}). A sequential ordering may be obtained through different mechanisms:
\begin{itemize}
    \item \textit{Consensus}: Using some form of agreement protocol between replicas to order updates consistently;
    \item \textit{Master state}: By storing the latest state of the account on a single device (ex: usb key or hardware token) and requiring any replica to update it after every operation;
    \item \textit{Single replica}: By enforcing that modifications can only be issued by a unique replica (device). A physical person may still control multiple accounts but each account should be linked to a single replica.
\end{itemize}

Any other mechanism is also possible as long as no concurrent state updates are possible.

\subsubsection{The balance may be negative sometimes}

If \texttt{burn} or \texttt{giveTo} operations may sometimes result in a negative balance during concurrent updates, then general complementary strategies are still possible:
\begin{itemize}
	\item \textit{Allow updates with small amounts compared to the balance}: In that case, the probability that there would be a sufficient number of concurrent small updates that would result in a negative balance is small and therefore in most likelihood future merges will result in a positive balance. This approach increases \textit{availability} (liveness) of the system will limited additional complexity;
	\item \textit{De-incentivize with negative reputation}: For example, reporting the number of times and the cumulative negative account balance over the lifetime of an $id$ will alert other participants that the $id$, and associated accounts, are less trust-worthy than others and should be de-prioritized during exchanges. This approach increases the trust of users (\textit{safety}) in the system;
	\item \textit{Incentivize and even enforce a positive balance to participate}: For example, a platform using eventually-consistent ledgers may degrade and even refuse services to an identifier $id$ unless their associated account is positive;  This approach also increases the trust of users (\textit{safety}) in the system;
\end{itemize}

In all previous cases, the service should allow an account to receive additional tokens \textit{after} its balance became negative in order to restore its positive state. 

The failure to implement negative feedback mechanisms as above, without the ability to prevent account owners from spending more tokens than they have, would most likely result in the devaluation of all tokens and the lost of trust in the system. We therefore recommend implementing at least \textit{some} negative feedback mechanism.

\subsection{Who manages the replicas?}

\begin{itemize}
	\item \textit{A single organization} \textit{(centralized)}
	\item \textit{Multiple organizations}  \textit{(federated)}
	\item \textit{End-users} \textit{(peer-to-peer)}
\end{itemize}

\section{Proofs}
\label{sec:proofs}

\subsection{Definitions}

We first make the semantics of algorithms more precise with the following definitions:
\begin{proof}
	\begin{pfenum}
		\item $\mathds{R}^+$ is the set of real positive numbers, including zero.
		\item $\mathds{I}$ is the set of all possible identifiers.
		\item $\mathds{C} \subseteq \mathds{I}$ is the set of identifiers allowed to create tokens.
		\item $\mathds{D}$ is the set of all possible \textit{grow-only dictionaries of grow-only counters} indexed by identifiers, \textit{i.e.}, $\mathds{D}$ is the power set of the cartesian product of $\mathds{I}$ and $\mathds{R}$ ($\mathds{D} = \mathcal{P}(\mathds{I} \times \mathds{R}))$, with the additional constraint that for any $D \in \mathds{D}$ and any $(\textit{id},r)$ such that $\textit{id} \in \mathds{I}$ and $r \in \mathds{R}$, $id$ appears in at most one tuple in $D$.
		\item $D \leq_\mathds{D} D' \Leftrightarrow D_* \subseteq D'_* \wedge \bigwedge\limits_{id \in D_*} D[id] \leq D'[id] $
		\item $\mathds{A}$ is the set of all possible account states, \textit{i.e.}, $\mathds{A}$ is the cartesian product $\mathds{I} \times \mathds{R}^+ \times \mathds{R}^+ \times \mathds{D} \times \mathds{D}$, such that $(A_{\footnotesize \textbf{id}}, A_\uparrow, A_\downarrow, A_\rightarrow, A_\leftarrow) \in \mathds{A}$. 
		\item $\mathds{L}$ is the set of all possible ledger states, \textit{i.e.} the power set of the cartesian product of $\mathds{I}$ and $\mathds{A}$ ($\mathds{L} = \mathcal{P}(\mathds{I} \times \mathds{A})$) with the additional constraints that for any $L \in \mathds{L}$ and any $(\textit{id}, A) \in L$ $\textit{id} = A_{\footnotesize \textbf{id}}$ and \textit{id} appears in at most one tuple in $L$.
	\end{pfenum}
\end{proof}

Note that because all replicas converge to the same state does not mean that the balances on all replicas are guaranteed to always be positive for any possible concurrent operations. We therefore discuss safety properties related to the balance separately in Section~\ref{sec:proof:balance}.

\subsection{Lemmas}

\subsubsection{The composition of least upper bounds is a least upper bound.}
\label{sec:lemma:lub-composition}
 
\begin{proof}
	\assume{\begin{pfenum}
		\item $\mathds{A}$ and $\mathds{B}$ are sets
		\item Binary relations $\leq_\mathds{A}$ and $\leq_\mathds{B}$ define semi-lattices $\mathds{S}_\mathds{A}$ and $\mathds{S}_\mathds{B}$
		\item Equality $=$ relationship exists for $\mathds{A}$ and $\mathds{B}$
		\item $a <_\mathds{A} a' \Leftrightarrow a \leq_\mathds{A} \wedge~ a \neq a'$ and $b <_\mathds{B} b' \Leftrightarrow a \leq_\mathds{B} \wedge~ b \neq b'$
		\item Binary operators $\alpha$ and $\beta$ compute least upper bounds, respectively in $\mathds{S}_\mathds{A}$ and $\mathds{S}_\mathds{B}$
	\end{pfenum}}
	\define{\begin{pfenum}
		\item $\mathds{C} = \mathds{A} \times \mathds{B}$, \textit{i.e.} the cartesian product of $\mathds{A}$ and $\mathds{B}$ such that $C \in \mathds{C} \Rightarrow (C = (a,b)) \wedge a \in \mathds{A} \wedge b \in \mathds{B}$
		\item $C \leq_\mathds{C} C' \Leftrightarrow (a,b) \leq_\mathds{C} (a',b') \Leftrightarrow a \leq_\mathds{A} a' \wedge~ b \leq_\mathds{B} b'$ which defines a semi-lattice $\mathds{S}_\mathds{C}$
		\item $C = C'  \Leftrightarrow (a,b) = (a',b') \Leftrightarrow a = a' \wedge b = b'$
		\item $C <_\mathds{C} C'  \Leftrightarrow C \leq_\mathds{C} C' \wedge C \neq C'$
		\item $C ~\tau~ C' \Leftrightarrow (a,b)~\tau~(a',b') \Leftrightarrow (a~\alpha~a', b~\beta~b')$
	\end{pfenum}}
	\prove{$C''  = C ~\tau~ C'$ is the least upper bound of $C$ and $C'$ in $\mathds{S}_\mathds{C}$}
	

	\step{lbl:lub:def-1}{$C \leq_\mathds{C} C''$}
	\begin{proof}
		\step{}{$C'' = C ~\tau~ C' = (a,b) ~\tau~ (a',b') = (a ~\alpha~ a', b ~\beta~ b') = (a'', b'')$}
		\begin{proof}
			By definition.
		\end{proof}
		
		\step{lbl:lub:def-1:1}{$a \leq_\mathds{A} (a ~\alpha~ a') = a \leq_\mathds{A} a''$}
		\begin{proof}
			By assumption on $\alpha$ and the definition of least upper bound.
		\end{proof}
		
		
		\step{lbl:lub:def-1:2}{$b \leq_\mathds{B} (b ~\beta~ b') = b \leq_\mathds{B} b''$}
		\begin{proof}
			By assumption on $\beta$ and the definition of least upper bound.
		\end{proof}
		
		\qedstep
		\begin{proof}
			By \stepref{lbl:lub:def-1:1} and \stepref{lbl:lub:def-1:2} and definition.
		\end{proof}
	\end{proof}
		
	\step{lbl:lub:def-2}{$C' \leq_\mathds{C} C''$}
	\begin{proof}
		\textit{Idem} \stepref{lbl:lub:def-1} by replacing $C$ for $C'$.
	\end{proof}	
		
	\step{lbl:lub:def-3}{$\nexists C''' \in \mathds{C} : C \leq_\mathds{C} C''' \wedge C' \leq_\mathds{C} C''' \wedge C''' <_\mathds{C} C'' $}
	\begin{proof}
		\step{lbl:lub:def-3-1}{
			\assume{\begin{pfenum}
				\item $a \in \mathds{A}$
				\item $a' \in \mathds{A}$
				\item $a'' = a ~\alpha~ a'$
			\end{pfenum}}
			\prove{$\nexists a''' \in \mathds{A} : a \leq_\mathds{A} a''' \wedge a' \leq_\mathds{A} a''' \wedge a''' <_\mathds{A} a'' $}
			
			\pf~By assumption, because $\alpha$ computes a least upper bound.
		}
		
		\step{lbl:lub:def-3-2}{
			\assume{\begin{pfenum}
				\item $b \in \mathds{B}$
				\item $b' \in \mathds{B}$
				\item $b'' = b ~\beta~ b'$
			\end{pfenum}}
			\prove{$\nexists b''' \in \mathds{B} : b \leq_\mathds{B} b''' \wedge b' \leq_\mathds{B} b''' \wedge b''' <_\mathds{B} b'' $}
			
			\pf~By assumption, because $\beta$ computes a least upper bound.
		}
		
		\qedstep
		\begin{proof}
			By the conjunction of \stepref{lbl:lub:def-3-1} and \stepref{lbl:lub:def-3-2}, associativity of $\wedge$ and definitions.
		\end{proof}
	\end{proof}
		
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:lub:def-1}, \stepref{lbl:lub:def-2}, and \stepref{lbl:lub:def-3}, which is the definition of a least upper bound.
	\end{proof}
\end{proof}

\subsection{Convergence}

To establish convergence, we need to establish that the states of the design form a \textit{monotonic semi-lattice}~\cite{shapiro:hal-00932836}, which involves three propositions: First, that all possible ledger states can be organized in a semi-lattice $\mathds{S}_\mathds{L}$ ordered by $\leq_\mathds{L}$. This is a requisite for the next two properties. Second, that merging two ledger states $L$ and $L'$ computes the \textit{Least Upper Bound} (LUB) of $L$ and $L'$ in $\mathds{S}_\mathds{L}$. This ensures that the merge is \textit{commutative}, \textit{associative}, and \textit{idempotent}, providing \textit{safety}, \textit{i.e.}, that replicas will agree on the final state regardless of ordering, delays, or duplication of merge operations. Third, that all operations modify the state $L$ of a replica such that the new state $L'$ is either equal or larger than the previous state $L$ in $\mathds{S}_\mathds{L}$ (\textit{monotonicity}). This ensures all state changes will be eventually reflected in the new state of all replicas, either because the same update(s) will have concurrently been applied or because the new state will be the result of a merge. Assuming an underlying communication medium that ensures new states to be eventually delivered to other replicas, the three propositions combined ensure both \textit{liveness} and \textit{safety}: all state changes are going to be replicated on all replicas \textit{and} all replicas will agree on the final state automatically, i.e. \textit{strong eventual consistency}~\cite{shapiro:hal-00932836}.

Because an account state is the composition of \textit{grow-only counters} ($A_\uparrow$ and $A_\downarrow$) and \textit{grow-only dictionaries of grow-only counters}~\cite{lavoie2023statebased} ($A_\leftarrow$ and $A_\rightarrow$), and the ledger state is a \textit{grow-only dictionary of accounts}, the convergence proofs are straight-forward. We first prove that account replicas converge, then prove that ledgers converge as well. To make the proofs more accessible to practitioners and non-mathematicians, we follow the structured proof approach suggested by Lamport~\cite{lamport2012write}.

\subsubsection{Account}
\label{sec:proof:account}



\begin{proof}
        \prove{The Account design listed in Alg.~\ref{alg:account} and Alg.~\ref{alg:account-ordering} is a state-based (convergent) CRDT.}
	\pfsketch ~An account is the composition of state-based grow-only counters and grow-only dictionaries of grow-only counters. The three properties of \textit{ordering}, \textit{least upper bound}, and \textit{monotonicity} that are sufficient to define a state-based CRDT are the conjunction of corresponding properties on grow-only counters and grow-only dictionaries of grow-only counters.
\end{proof}

	
\begin{proof}
	\step{lbl:account:ordering}{
		\textbf{Ordering:} 
		Ordering $\mathds{A}$ by $\leq_\mathds{A}$ (Alg.~\ref{alg:account-ordering}) forms a semi-lattice $\mathds{S}_\mathds{A}$.
	}
	\begin{proof}
		\pfsketch~ $\leq_\mathds{A}$ is the conjunction of the $\subseteq$ and $\leq$ relationships, respectively forming partial orders on sets of identifiers in dictionaries in $\mathds{D}$ and real positive numbers $\mathds{R}^+$ that compose the possible states. Specifically:
		\begin{pfenum}
			\item $\leq$ creates partial orders on $A_\downarrow$ and $A_\uparrow$ counters (\textit{created} and \textit{burned} booleans).
			\item conjunction of $\subseteq$ on dictionary keys and $\leq$ on dictionary values creates partial orders on $A_\rightarrow$ and $A_\leftarrow$ dictionaries, (\textit{given} and \textit{acked} booleans).
			\item The conjunction of \textit{created}, \textit{burned}, \textit{given}, and \textit{acked} is also a partial order.
		\end{pfenum} 		
		Detailed proofs have already been published for grow-only counters of natural numbers, grow-only dictionaries of grow-only counters, and the conjunction of partial orders~\cite{lavoie2023statebased}. Those proofs apply directly to this proposition by replacing natural numbers by real numbers and adding a conjunction of dictionaries and grow-only counters.
	\end{proof}

	\step{lbl:account:lub}{
	        \textbf{Least Upper Bound:} 
		\assume{\begin{pfenum}
			\item $A \in \mathds{A}, A' \in \mathds{A}, A'' \in \mathds{A}$
			\item \label{lbl:account:assumption:id} $A_{\footnotesize \textbf{id}} = A'_{\footnotesize \textbf{id}}$
		\end{pfenum}}
		
		\prove{$A'' = A \sqcup_\mathds{A} A'$ is the LUB of $A$ and $A'$ in $\mathds{S}_\mathds{A}$.}}

		\begin{proof}
			\step{lbl:account:lub:counter}{ $A''_\uparrow = \texttt{max}(A_\uparrow, A'_\uparrow)$ is the least upper bound of $A_\uparrow$ and $A'_\uparrow$ in the semi-lattice of real numbers $\mathds{S}_{\mathds{R}^+}$ formed by $\leq$. Idem for $A''_\downarrow = \texttt{max}(A_\downarrow, A'_\downarrow)$ in $\mathds{S}_{\mathds{R}^+}$.}
			\begin{proof}
				Same proof as in Annex of~\cite{lavoie2023statebased}, but on real numbers instead.
			\end{proof}
			
			\step{lbl:account:lub:dict}{$A''_{\leftarrow}$ is the least upper bound of $A_{\leftarrow}$ and $A'_{\leftarrow}$  in the semi-lattice of dictionaries $\mathds{S}_\mathds{D}$ formed by $\leq_\mathds{D}$. Idem for $A''_{\rightarrow }$ in $\mathds{S}_\mathds{D}$ formed by $\leq_\mathds{D}$.
			}
			\begin{proof}
				Same proof as for dictionaries in Annex of~\cite{lavoie2023statebased}: their \texttt{compare} method on dictionaries is defined similarly as the  \textit{given} and \textit{acked} conditions of $\leq_\mathds{A}$ in Alg.~\ref{alg:account-ordering}.
			\end{proof}
			
			\qedstep
			\begin{proof}
				By \stepref{lbl:account:lub:counter} and \stepref{lbl:account:lub:dict} and LUB composition lemma of Section~\ref{sec:lemma:lub-composition}.
			\end{proof}
		\end{proof}

	\step{lbl:account:monotonicity}{
	\textbf{Monotonicity:}
	All operations that may generate a new state, when applied on account state $A$ and any possible arguments, result in a new account state either equal or larger than $A$ in $\mathds{S}_\mathds{A}$ according to $\leq_\mathds{A}$.}
	
	\begin{proof}
		\step{}{\case{$A = \texttt{Initialize}(id)$}}
		\begin{proof}
			Initializes a new $A$ but not from an existing state, so monotonicity does not apply.
		\end{proof}
		
		\step{}{\case{$A' = \texttt{create}(A,\textit{amount})$}}
		\begin{proof}
			\step{}{\case{$A_{\footnotesize \textbf{id}} \in \mathds{C} \wedge \textit{amount} > 0$}}
			\begin{proof}
				$A'_\uparrow = A_\uparrow + \textit{amount} > A_\uparrow$ and all others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
			\end{proof}
			
			\step{}{\case{$A_{\footnotesize \textbf{id}} \notin \mathds{C} \vee \textit{amount} \leq 0$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{burn}(A,\textit{amount})$}}
		\begin{proof}
			\step{}{\case{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}}
			\begin{proof}
				$A'_\downarrow = A_\downarrow + \textit{amount} > A_\downarrow$ and all others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$. 
			\end{proof}
			
			\step{}{\case{$\textit{amount} \leq 0 \vee \texttt{balance}(A) < \textit{amount}$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{giveTo}(A,\textit{amount},\textit{id})$}}
		\begin{proof}
			\step{}{\case{$\textit{amount} > 0 \wedge \texttt{balance}(A) \geq \textit{amount}$}}
			\begin{proof}
				\step{}{\case{$\textit{id} \notin A_\rightarrow [id]$}}
				\begin{proof}
					$A_{\rightarrow *} \cup \{ \textit{id} \} = A'_{\rightarrow *}$ therefore $A_{\rightarrow *} \subset A'_{\rightarrow *}$. All other properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof}
				
				\step{}{\case{$\textit{id} \in A_\rightarrow[id]$}}
				\begin{proof}
					$A_\rightarrow[id] + \textit{amount} = A'_\rightarrow[id]$ therefore $A_\rightarrow[id] < A'_\rightarrow[id]$. All others properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof} 
			\end{proof}
			
			\step{}{\case{$\textit{amount} \leq 0 \vee \texttt{balance}(A) < \textit{amount}$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$A' = \texttt{ackFrom}(A,B)$}}
		\begin{proof}
			\step{}{\case{$A_{\scriptsize \textbf{id}} \in B_{\rightarrow *} \wedge \texttt{balance}(B) \geq 0$}}
			\begin{proof}
				\step{}{\case{$B_{\scriptsize \textbf{id}} \notin A_{\leftarrow *}$}}
				\begin{proof}
					$A_{\leftarrow *} \cup \{ B_{\scriptsize \textbf{id}} \} = A'_{\leftarrow *}$ therefore $A_{\leftarrow *} \subset A'_{\leftarrow *}$. All other properties of $A'$ are equal to those of $A$, therefore $A <_\mathds{A} A'$.
				\end{proof}
				
				\step{}{\case{$B_{\scriptsize \textbf{id}} \in A_{\leftarrow *}$}}
				\begin{proof}
					$A'_\leftarrow[B_{\scriptsize \textbf{id}}] = \texttt{max}(A_\leftarrow[B_{\scriptsize \textbf{id}}], B_\leftarrow[A_{\scriptsize \textbf{id}}])$ therefore $A_\leftarrow[B_{\scriptsize \textbf{id}}] \leq A'_\leftarrow[B_{\scriptsize \textbf{id}}]$. All others properties of $A'$ are equal to those of $A$, therefore $A \leq_\mathds{A} A'$.
				\end{proof} 
			\end{proof}
			
			\step{}{\case{$A_{\scriptsize \textbf{id}} \notin B_{\rightarrow *} \vee \texttt{balance}(B) < 0$}}
			\begin{proof}
				$A=A'$
			\end{proof}
		\end{proof}
		
		\step{}{\case{$b = \texttt{balance}(A)$}}
		\begin{proof}
			Does not modify the state of $A$.
		\end{proof}
		
		\step{}{\case{$b = \texttt{unackedFrom}(A,B)$}}
		\begin{proof}
			Does not modify the state of $A$.
		\end{proof}
		
		\step{}{\case{$b = A \leq_\mathds{A} A'$}}
		\begin{proof}
			Does not modify the state of $A$ or $A'$.
		\end{proof}
		
		\step{}{\case{$A'' = A \sqcup_\mathds{A} A'$}}
		\begin{proof}
			$A \leq_\mathds{A} A'' \wedge A' \leq_\mathds{A} A''$ because $\sqcup_\mathds{A}$ computes a LUB in $\mathds{S}_\mathds{A}$.
		\end{proof}
	\end{proof}
	
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:account:ordering}, \stepref{lbl:account:lub}, \stepref{lbl:account:monotonicity} which is the definition of a state-based CRDT.
	\end{proof}
\end{proof}


\subsubsection{Ledger}

%\begin{theorem}

%\end{theorem}

\label{th:ledger-crdt}
\prove{The ledger of Algorithm~\ref{alg:ledger} is a state-based (convergent) conflict-free replicated data type.}
\begin{proof}
	\pfsketch~ The ledger is a grow-only dictionary of accounts, that are themselves state-based CRDTs.
	
	\step{lbl:ledger:ordering}{
		\textbf{Ordering:} 
		Ordering $\mathds{L}$ by $\leq_\mathds{L}$ (Alg.~\ref{alg:ledger}) forms a semi-lattice $\mathds{S}_\mathds{L}$.
	}
	\begin{proof}
		\pfsketch~ The ordering of $\mathds{L}$ is the conjunction the $\subseteq$ partial order on sets of identifiers that serve as dictionary keys, and $\leq_\mathds{A}$ on account states that serve as dictionary values. The proof is similar as for grow-only dictionaries of grow-only counters~\cite{lavoie2023statebased}.
	\end{proof}
	
	\step{lbl:ledger:lub}{
	        \textbf{Least Upper Bound:} 
		\assume{\begin{pfenum}
			\item $L \in \mathds{L}, L' \in \mathds{L}$
		\end{pfenum}}
		
		\prove{$L'' = L \sqcup_\mathds{L} L'$ is the LUB of $L$ and $L'$ in $\mathds{S}_\mathds{L}$.}}
	\begin{proof}		
		\step{lbl:ledger:lub:def-1}{$L \leq_\mathds{L} L''$}
		\begin{proof}
			\step{lbl:ledger:lub:def-1:1}{$L_* \subseteq L''_*$}
			\begin{proof}
				$L_* \subseteq (L_* \cup L'_*) = L''_*$.
			\end{proof}
			
			\step{lbl:ledger:lub:def-1:2}{$\forall_{\textit{id} \in L_*} L[\textit{id}] \leq_\mathds{A} L''[\textit{id}]$}
			\begin{proof}
				\step{lbl:ledger:lub:def-1:2:1}{\case{$\textit{id} \in L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$ L[\textit{id}] \leq_\mathds{A} L[\textit{id}] \sqcup_\mathds{A}  L'[\textit{id}]  = L''[\textit{id}]$
				\end{proof}
				
				\step{lbl:ledger:lub:def-1:2:2}{\case{$\textit{id} \in L_* \wedge \textit{id} \notin L'_*$}}
				\begin{proof}
					$L[\textit{id}] = L''[\textit{id}]$
				\end{proof}
			\end{proof}
			
			\qedstep
			\begin{proof}
				$\leq_\mathds{L}$ is the conjunction of \stepref{lbl:ledger:lub:def-1:1} and \stepref{lbl:ledger:lub:def-1:2}.
			\end{proof}
		\end{proof}
		
		\step{lbl:ledger:lub:def-2}{$L' \leq_\mathds{L} L''$}
		\begin{proof}
			\textit{Idem} \stepref{lbl:ledger:lub:def-1} on $L'$ instead of $L$.
		\end{proof}
		
		\step{lbl:ledger:lub:def-3}{$\nexists L''' \in \mathds{L} : L \leq_\mathds{L} L''' \wedge L' \leq_\mathds{L} L''' \wedge L''' <_\mathds{L} L''$}
		\begin{proof}
			\step{lbl:ledger:lub:def-3:ids}{It is not possible for $L_* \subseteq L'''_* \wedge L'_* \subseteq L'''_* \wedge L'''_* \subset L''_*$. }
			\begin{proof}
				$L''_* = L_* \cup L'_*$ is the least upper-bound of $L_*$ and $L'_*$ in $\mathds{S}_{\mathcal{P}(\mathds{I})}$ ordered by $\subseteq$ because $\cup$ computes the least upper bound on sets of identifiers (see \cite{lavoie2023statebased}).  
			\end{proof}
			
			\step{lbl:ledger:lub:def-3:accounts}{
				\assume{$L'''_* \subseteq L''_*$ (otherwise it is not possible for $L''' \leq_\mathds{L} L''$)}
				\prove{$\forall_{\textit{id} \in L'''_*}$, it is not possible for $L'''[\textit{id}]  <_\mathds{A} L''[\textit{id}]$ and $L[\textit{id}] \leq_\mathds{A} L'''[\textit{id}]$ (if $id \in L_*$) and $L'[\textit{id}] \leq_\mathds{A} L'''[\textit{id}]$  (if $id \in L'_*$)} }
			\begin{proof}
				\step{}{\case{$\textit{id} \in L_* \wedge \textit{id} \notin L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L[\textit{id}]$
				\end{proof}
				
				\step{}{\case{$\textit{id} \notin L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L'[\textit{id}]$
				\end{proof}
				
				\step{}{\case{$\textit{id} \in L_* \wedge \textit{id} \in L'_*$}}
				\begin{proof}
					$L''[\textit{id}] = L[\textit{id}] \sqcup_\mathds{A} L'[\textit{id}] = \textit{LUB}(L[\textit{id}], L'[\textit{id}])$
				\end{proof}
			\end{proof}
			
			\qedstep
			\begin{proof}
				Because both \stepref{lbl:ledger:lub:def-3:ids} and \stepref{lbl:ledger:lub:def-3:accounts} are sufficient conditions (no other condition could make the proposition true). 
			\end{proof}
		\end{proof}
		
	
		\qedstep
		\begin{proof}
			The conjunction of \stepref{lbl:ledger:lub:def-1}, \stepref{lbl:ledger:lub:def-2}, \stepref{lbl:ledger:lub:def-3} is the definition of a least upper bound.
		\end{proof}
	\end{proof}

	\step{lbl:ledger:monotonicity}{		
	\textbf{Monotonicity:}
	All operations that may generate a new state, when applied on ledger state $L$ and any possible arguments, result in a new ledger state either equal or larger than $L$ in $\mathds{S}_\mathds{L}$ according to $\leq_\mathds{L}$.}
	\begin{proof}
		\step{}{\case{$L = \texttt{initialize}()$}}
		\begin{proof}
			Initializes a new $L$ but not from an existing state so monotonicity need not apply.
		\end{proof}
		
		\step{}{\case{$L' = \texttt{add}(L,A)$}}
		\begin{proof}
			\step{}{\case{$A_{\scriptsize \textbf{id}} \notin L_*$}}
			\begin{proof}
				$L_* \subset L_* \cup \{ A_{\scriptsize \textbf{id}} \} = L'_*$
			\end{proof}
			
			\step{}{\case{$A_{\scriptsize \textbf{id}} \in L_*$}}
			\begin{proof}
				$L[A_{\scriptsize \textbf{id}}] \leq_\mathds{A} L[A_{\scriptsize \textbf{id}}] \sqcup_\mathds{A} A$ and all other properties of $L'$ are equal to those of $L$.
			\end{proof}
		\end{proof}
			
		\step{}{\case{$b = L \leq_\mathds{L} L'$}}
		\begin{proof}
			Does not return a new ledger state so monotonicity need not apply.
		\end{proof}
			
		\step{}{\case{$L'' = L \sqcup_\mathds{L} L'$}}
		\begin{proof}
		 	By definition because $L''$ is a least upper bound.
		\end{proof}
			
		\step{}{\case{$B = \texttt{balances}(L)$}}
		\begin{proof}
			Does not return a new ledger state so monotonicity need not apply.
		\end{proof}

	\end{proof}

	
	\qedstep
	\begin{proof}
		By the conjunction of \stepref{lbl:ledger:ordering}, \stepref{lbl:ledger:lub}, \stepref{lbl:ledger:monotonicity} which is the definition of a state-based CRDT.
	\end{proof}
\end{proof}

\subsection{Balance}
\label{sec:proof:balance}

\subsubsection{Unavoidable tradeoffs}

%\begin{theorem}
\label{proof:positive-bal-seq-order}
If the balance of any account $A \in \mathds{A}$ should be greater or equal to 0 at all times, then all operations on the account should be sequentially ordered, \textit{i.e.}, for any pair of operations $f,f'$ on $A$, $f$ happens before $f'$ ($f \rightarrow f'$) or $f'$ happens before $f$ ($f \leftarrow f'$).
%\end{theorem}


For the theorems below, $\mathds{A}$ is the set of all accounts participating in ledger $L$ and $\mathds{C} \subseteq \mathds{A}$ is the set of accounts allowed to create tokens.

\subsubsection{Safety}

%\begin{lemma}
For every pair of accounts $R,S \in \mathds{A}$, it is always true that $R_{\leftarrow S.id} \leq S_{\rightarrow R.id}$.
%\end{lemma}

%\begin{theorem}
(Safety): It is always true that $\sum\limits_{A \in \mathds{A}} \texttt{balance}(A) \leq  \sum\limits_{C \in \mathds{C}} C_\uparrow - \sum\limits_{A \in \mathds{A}} A_\downarrow$.
%\end{theorem}


\subsubsection{Liveness}

%\begin{lemma}
If a receiver account $R \in \mathds{A}$ eventually acknowledges all amounts sent from a sender account $S \in \mathds{A}$ to $R$, then eventually $R_{\leftarrow S.id} = S_{\rightarrow R.id}$.
%\end{lemma}

%\begin{theorem}
(Liveness): If every account $R \in \mathds{A}$ eventually acknowledges all amounts sent by every account $S \in \mathds{A}$ (including $R=S$), then eventually $\sum\limits_{A \in \mathds{A}} \texttt{balance}(A) = \sum\limits_{C \in \mathds{C}} C_\uparrow - \sum\limits_{A \in \mathds{A}} A_\downarrow$.
%\end{theorem}

\section{System Model}




\section{Related Work}

Consensus number of a crypto-currency.

 In contrast to Bitcoin~\cite{bitcoin}, we decouple the sending and reception of tokens in a transaction: upon a \textit{give} operation, the balance of the sender is immediately decreased but the receiver balance is not immediately increased by the same amount.  The increase on the receiver side happens only  after an explicit \textit{acknowledgement}. 
 
Delta-CRDT (see portfolio example)~\cite{Almeida2018delta}
 
\section{Future Work}
 
\subsection{Limiting the Creator Set}

\subsection{Tolerating Arbitrary Failures}

	\subsubsection{Collusion-Resistance}

\subsection{Limiting the Visibility of Transactions}

\subsection{Eventually-Consistent Reputation and Access-Control Mechanisms}

\subsection{Implementation Techniques for Resource-Limited Devices}

\section{Conclusion}
\label{sec:conclusion}

Implementation techniques for restricting token creation, which can potentially be based on cryptographic techniques, will be covered in future work.

\section{Acknowledgements}
\label{sec:acknowledgements}

We thank Christian F. Tschudin for fostering a research environment allowing detours and playfulness in the process, as well as providing financial support for this work and feedback on early drafts. 

\newpage

\bibliographystyle{plainurl}
\bibliography{main}

\newpage
\appendix

\section{Notation and Conventions}
\label{apdx:notation}

We use notations and conventions that are good graphic mnemonics for the concepts and make the algorithms easier to reason about in the proofs (Section~\ref{sec:proofs}). The semantics are:

\begin{itemize}
	\item \textbf{Variables} are written in \textit{italic}:
		\begin{itemize}
			\item  lower case when containing literal values, ex: $id$;
			\item upper case when containing an object with multiple fields, a dictionary with multiple key-value pairs, or a set with multiple elements. For example, $A$ for account object, $L$ for a ledger dictionary, and $S$ for a set;
		\end{itemize}
	\item An \textbf{object's field} is accessed using a subscript, ex: $A$'s identifier stored in field $\textbf{id}$ is accessed $A_{\scriptsize \textbf{id}}$;
	\item An empty \textbf{dictionary} is written $\{\}$, accessing a dictionary $L$'s value stored under key $id$ is written $L[id]$, accessing all the keys of $L$ is written $L_*$;
	\item \textbf{Assigning} a new value to a variable, a field, or a dictionary entry uses $\leftarrow$, ex: $id \leftarrow id'$, $A_{\scriptsize\textbf{id}} \leftarrow id$, $L[id] \leftarrow A$. Variables, fields, and dictionaries are mutable and can be modified in place;
	 \item A \textbf{key-value} pair for dictionaries is written $\textit{key} \rightarrow \textit{value}$;
	 \item We use "dictionary-comprehension", similar to Python, for inline initialization fo dictionares, ex: ${ \textit{key} \rightarrow \textit{value} ~\textbf{for}~ \textit{key} ~\textbf{in}~ K }$;
	\item \textbf{Different states} for replicas of objects or dictionaries are written with $'$ and $''$ using the same variable name, ex: $A, A', A''$. We represent output values of functions using variable names with $'$ or $''$ to show they are later states of the same replica;
	\item The  \textbf{flow of tokens} on an account is suggested by the direction of an arrow used as a field name: 
		\begin{itemize}
			\item $A_\uparrow$ returns the number created tokens, which increases the account balance without transfers;
			\item $A_\downarrow$ returns the number of burned tokens, which decreases the account balance without transfers;
			\item $A_{\leftarrow}$ is a dictionary and $A_{\leftarrow}[id]$ returns the number of tokens received from $id$ and therefore flowing \textit{into} account $A$ (the arrow is a subscript to distinguish from assignment);
			\item $A_{\rightarrow}$ is a dictionary and $A_{\rightarrow}[id]$ returns the number of tokens given to $id$ therefore flowing \textit{out of} account $A$;
		\end{itemize}
\end{itemize}

Apart from these, we use common mathematical and pseudo-code conventions: 
\begin{itemize}
	\item $x \in X$ is an element $x$ in a set $X$ and $x \notin X$ means $x$ is not in a set $X$;
	\item $X \subseteq Y$ means $X$ is a subset of $Y$ which may include up to all elements of $Y$;
	 \item $\sum$ is a summation;
	 \item $\sum\limits_{x \in X} x$ is the sum of all elements in $X$;
	 \item $\leq$ is smaller or equal;
	 \item $\bigwedge$ and $\textbf{and}$ both represent a logical \textit{and};
	 \item $\bigwedge\limits_{x \in X} x$ is the logical and between all elements in $X$;
	 \item $\textbf{for}~x ~\textbf{in}~ X~\textbf{do}$ iterates over all values in $X$ sequentially assigning them to $x$.
\end{itemize}



\end{document}  